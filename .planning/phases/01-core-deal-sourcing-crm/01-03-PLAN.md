---
phase: 01-core-deal-sourcing-crm
plan: "03"
type: tdd
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/lib/qualification/engine.ts
  - src/lib/qualification/operators.ts
  - src/lib/qualification/types.ts
  - src/lib/qualification/__tests__/engine.test.ts
  - src/lib/qualification/__tests__/operators.test.ts
  - src/app/api/rules/route.ts
  - src/app/api/deals/[id]/qualify/route.ts
autonomous: true
requirements:
  - QA-01
  - QA-02
  - QA-03
  - QA-04
  - QA-05

must_haves:
  truths:
    - "User can create a custom qualification rule (e.g., 'reject if equity < 30%')"
    - "User can create a scoring rule (e.g., 'add 20 points if foreclosure signal present')"
    - "System automatically evaluates all enabled rules when a deal is analyzed"
    - "FILTER rules that fail immediately reject the deal (status becomes REJECTED)"
    - "SCORE_COMPONENT rules sum up to a qualification_score (0-100)"
    - "Deals scoring 50+ are QUALIFIED; below 50 remain ANALYZING"
    - "User can see the calculated offer price (MAO = ARV × 0.70 − repair costs)"
    - "Only qualified deals (status = QUALIFIED) appear in the filtered deal list"
  artifacts:
    - path: "src/lib/qualification/engine.ts"
      provides: "evaluateDeal() function — runs rules against property, returns score + status + breakdown"
      exports: ["evaluateDeal", "calculateMAO"]
    - path: "src/lib/qualification/operators.ts"
      provides: "Pure operator evaluation functions: GT, LT, EQ, IN, CONTAINS, RANGE, NOT_CONTAINS"
      exports: ["evaluateOperator"]
    - path: "src/lib/qualification/__tests__/engine.test.ts"
      provides: "Test coverage for all rule combinations and edge cases"
    - path: "src/app/api/rules/route.ts"
      provides: "CRUD API for qualification rules"
      exports: ["GET", "POST", "PUT", "DELETE"]
    - path: "src/app/api/deals/[id]/qualify/route.ts"
      provides: "POST endpoint that triggers rule evaluation on a deal"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/deals/[id]/qualify/route.ts"
      to: "src/lib/qualification/engine.ts"
      via: "calls evaluateDeal(property, rules), updates deal.status + qualification_score"
      pattern: "evaluateDeal"
    - from: "src/lib/qualification/engine.ts"
      to: "prisma.ruleEvaluationLog"
      via: "logs each rule result to DB after evaluation"
      pattern: "prisma\\.ruleEvaluationLog\\.create"
---

<objective>
Implement the deal qualification rules engine using TDD. This is the core business logic engine that determines which deals are winners.

Purpose: TDD here catches logic errors before they manifest as bad qualification decisions (offensive lowball offers, missed winners). The engine must be deterministic and testable in isolation from the database.

Output: A pure TypeScript rules engine (evaluateDeal) with full test coverage, wired to CRUD API endpoints for rule management, and a qualification trigger endpoint that evaluates a deal and updates its status.
</objective>

<execution_context>
@/Users/jakezebe/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakezebe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-deal-sourcing-crm/01-RESEARCH.md
@.planning/phases/01-core-deal-sourcing-crm/01-01-SUMMARY.md
</context>

<feature>
  <name>Deal Qualification Rules Engine</name>
  <files>
    src/lib/qualification/engine.ts
    src/lib/qualification/operators.ts
    src/lib/qualification/types.ts
    src/lib/qualification/__tests__/engine.test.ts
    src/lib/qualification/__tests__/operators.test.ts
  </files>
  <behavior>
    Install vitest: `npm install -D vitest @vitest/coverage-v8`
    Add to package.json: `"test": "vitest run"`, `"test:watch": "vitest"`

    **Operator cases (operators.ts):**
    - GT: evaluateOperator(150000, 'GT', 100000) → true
    - GT: evaluateOperator(50000, 'GT', 100000) → false
    - LT: evaluateOperator(3, 'LT', 5) → true
    - EQ: evaluateOperator('FORECLOSURE', 'EQ', 'FORECLOSURE') → true
    - IN: evaluateOperator('CA', 'IN', ['CA', 'TX', 'FL']) → true
    - CONTAINS: evaluateOperator({ foreclosure: true, preforeclosure: false }, 'CONTAINS', 'foreclosure') → true
    - RANGE: evaluateOperator(75, 'RANGE', { min: 60, max: 90 }) → true
    - RANGE: evaluateOperator(45, 'RANGE', { min: 60, max: 90 }) → false
    - NOT_CONTAINS: evaluateOperator({ foreclosure: false }, 'NOT_CONTAINS', 'foreclosure') → true (key absent/false)

    **Engine cases (engine.ts):**

    Case 1 — FILTER rule fails → immediate REJECTED:
    ```
    property: { estimatedValue: 30000 }
    rules: [{ ruleType: 'FILTER', fieldName: 'estimatedValue', operator: 'GT', value: 50000, weight: 0 }]
    result: { status: 'REJECTED', qualificationScore: 0, ruleBreakdown: [{ ruleId, result: 'FAIL', scored: 0 }] }
    ```

    Case 2 — All FILTER rules pass, scoring accumulates:
    ```
    property: { estimatedValue: 150000, distressSignals: { foreclosure: true }, ownerOccupied: false }
    rules: [
      { ruleType: 'FILTER', fieldName: 'estimatedValue', operator: 'GT', value: 50000, weight: 0 },
      { ruleType: 'SCORE_COMPONENT', fieldName: 'distressSignals', operator: 'CONTAINS', value: 'foreclosure', weight: 25 },
      { ruleType: 'SCORE_COMPONENT', fieldName: 'ownerOccupied', operator: 'EQ', value: false, weight: 15 },
    ]
    result: { status: 'QUALIFIED', qualificationScore: 40, ... }
    // Note: 40 < 50 threshold means ANALYZING, not QUALIFIED — test this edge case
    ```

    Case 3 — Score >= 50 → QUALIFIED:
    ```
    rules with combined weight >= 50, all SCORE rules pass
    result: { status: 'QUALIFIED', qualificationScore: 65 }
    ```

    Case 4 — Disabled rule is skipped:
    ```
    rules: [{ ...rule, enabled: false }]
    result: rule not evaluated, not in breakdown
    ```

    Case 5 — MAO calculation:
    ```
    calculateMAO({ arv: 200000, repairCosts: 50000 })
    result: { mao: 90000, formula: '(200000 × 0.70) − 50000' }
    ```

    Case 6 — Nested field access via dot notation:
    ```
    property: { rawData: { mortgageRate: 4.5 } }
    rule: { fieldName: 'rawData.mortgageRate', operator: 'LT', value: 5 }
    result: FILTER passes
    ```
  </behavior>
  <implementation>
    **After tests pass, implement:**

    `src/lib/qualification/operators.ts`:
    - evaluateOperator(fieldValue: unknown, operator: Operator, ruleValue: unknown): boolean
    - CONTAINS checks object keys where value is truthy OR array includes
    - RANGE expects ruleValue as { min, max }
    - GT/LT/EQ work on numbers and strings
    - Use lodash `_.get(property, fieldName)` for nested field access

    `src/lib/qualification/engine.ts`:
    - evaluateDeal(property: PropertyForEvaluation, rules: QualificationRule[]): EvaluationResult
    - Filter out disabled rules first
    - Evaluate FILTER rules first — short-circuit on first FILTER failure
    - Accumulate SCORE_COMPONENT scores
    - Score >= 50 → QUALIFIED; < 50 → ANALYZING
    - Return full ruleBreakdown array for transparency

    - calculateMAO(arv: number, repairCosts: number): { mao: number; formula: string }
    - Formula: mao = (arv * 0.70) - repairCosts
    - Return both the number AND the formula string for display

    `src/app/api/rules/route.ts`:
    - GET: fetch all rules for user (userId from Clerk auth)
    - POST: create new rule (validate via Zod)
    - PUT /api/rules/[id]: update rule (verify ownership)
    - DELETE /api/rules/[id]: delete rule (verify ownership)
    - Include 3 default system rules when user has no rules yet (seeded on first GET):
      - FILTER: estimatedValue GT 50000 (reject deals under $50k ARV)
      - SCORE: distressSignals CONTAINS 'foreclosure' → weight 25
      - SCORE: daysOnMarket GT 60 → weight 20

    `src/app/api/deals/[id]/qualify/route.ts`:
    - POST: loads deal + property + user's rules, calls evaluateDeal()
    - Updates deal.status + deal.qualificationScore in DB
    - Creates RuleEvaluationLog entries for each rule result
    - Returns EvaluationResult to caller
  </implementation>
</feature>

<verification>
1. `npm test` — all tests pass (operators + engine)
2. Coverage: operators.ts at 100%, engine.ts at > 90%
3. POST /api/deals/:id/qualify on a deal with failing FILTER rule → deal.status becomes REJECTED
4. POST /api/deals/:id/qualify on a deal with score >= 50 → deal.status becomes QUALIFIED
5. GET /api/rules returns 3 default system rules for new user
6. POST /api/rules creates new rule, GET shows it in list
7. `npm run build` TypeScript passes
</verification>

<success_criteria>
- All operator tests pass (GT, LT, EQ, IN, CONTAINS, RANGE, NOT_CONTAINS)
- Engine correctly short-circuits on FILTER failure returning REJECTED with score 0
- Engine correctly sums SCORE_COMPONENT weights and returns QUALIFIED when score >= 50
- calculateMAO returns correct value: (ARV × 0.70) − repair costs
- Rule CRUD endpoints work with user scoping
- RuleEvaluationLog entries created for each deal qualification event
- TypeScript strict mode: no `any` types in engine.ts or operators.ts
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-deal-sourcing-crm/01-03-SUMMARY.md`
</output>
