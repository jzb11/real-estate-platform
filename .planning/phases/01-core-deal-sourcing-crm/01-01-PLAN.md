---
phase: 01-core-deal-sourcing-crm
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - prisma/migrations/
  - src/lib/db.ts
  - src/middleware.ts
  - src/app/layout.tsx
  - src/app/(auth)/sign-in/[[...sign-in]]/page.tsx
  - src/app/(auth)/sign-up/[[...sign-up]]/page.tsx
  - src/app/api/webhooks/clerk/route.ts
  - .env.example
  - package.json
autonomous: true
requirements:
  - AUTH-01
  - AUTH-02
  - AUTH-03
  - AUTH-04

must_haves:
  truths:
    - "User can create an account with email/password via Clerk sign-up page"
    - "User session persists across browser refresh (Clerk JWT in cookie)"
    - "User can reset password via email link from Clerk-managed flow"
    - "User can log out from any page and session is cleared"
    - "All application routes are protected — unauthenticated users are redirected to sign-in"
    - "Database tables are created: properties, deals, deal_history, contact_logs, consent_records, do_not_call_list, qualification_rules, rule_evaluation_logs, kb_articles"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Full database schema with all Phase 1 tables"
      contains: "model Deal"
    - path: "src/middleware.ts"
      provides: "Route protection via Clerk auth middleware"
      exports: ["default"]
    - path: "src/app/api/webhooks/clerk/route.ts"
      provides: "Clerk webhook to sync user creation to DB users table"
      exports: ["POST"]
    - path: "src/lib/db.ts"
      provides: "Prisma client singleton for DB access"
      exports: ["prisma"]
  key_links:
    - from: "src/middleware.ts"
      to: "Clerk auth"
      via: "clerkMiddleware() wrapping all routes"
      pattern: "clerkMiddleware"
    - from: "src/app/api/webhooks/clerk/route.ts"
      to: "prisma.user"
      via: "Svix webhook verification then prisma.user.upsert"
      pattern: "prisma\\.user\\.(create|upsert)"

user_setup:
  - service: clerk
    why: "Managed authentication provider (email/password, session management, password reset)"
    env_vars:
      - name: NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY
        source: "Clerk Dashboard -> API Keys"
      - name: CLERK_SECRET_KEY
        source: "Clerk Dashboard -> API Keys"
      - name: CLERK_WEBHOOK_SECRET
        source: "Clerk Dashboard -> Webhooks -> Add Endpoint (point to /api/webhooks/clerk)"
    dashboard_config:
      - task: "Enable Email/Password authentication"
        location: "Clerk Dashboard -> User & Authentication -> Email, Phone, Username"
      - task: "Add webhook endpoint for user.created event"
        location: "Clerk Dashboard -> Webhooks -> Add Endpoint -> URL: https://your-domain/api/webhooks/clerk"
  - service: postgresql
    why: "Primary database"
    env_vars:
      - name: DATABASE_URL
        source: "PostgreSQL connection string (e.g., Supabase, Neon, or local postgres://)"
---

<objective>
Bootstrap the entire Phase 1 technical foundation: Next.js 15 project with Clerk authentication and the complete PostgreSQL database schema for all Phase 1 entities.

Purpose: Every other Phase 1 plan depends on this foundation. Authentication protects all routes from day one. The database schema — designed TCPA-first — defines the data contracts all other plans build against.

Output: A running Next.js 15 app where unauthenticated users are redirected to Clerk sign-in, authenticated users reach a placeholder dashboard, and the complete Prisma schema is migrated to PostgreSQL.
</objective>

<execution_context>
@/Users/jakezebe/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakezebe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-deal-sourcing-crm/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bootstrap Next.js 15 project with Clerk authentication</name>
  <files>
    package.json
    src/middleware.ts
    src/app/layout.tsx
    src/app/(auth)/sign-in/[[...sign-in]]/page.tsx
    src/app/(auth)/sign-up/[[...sign-up]]/page.tsx
    src/app/(dashboard)/layout.tsx
    src/app/(dashboard)/dashboard/page.tsx
    src/app/api/webhooks/clerk/route.ts
    .env.example
    .env.local
  </files>
  <action>
    1. Initialize Next.js 15 project: `npx create-next-app@latest . --typescript --tailwind --eslint --app --src-dir --import-alias "@/*"` (if project doesn't exist yet; otherwise install into existing dir).

    2. Install dependencies:
       ```
       npm install @clerk/nextjs svix zod prisma @prisma/client
       npm install -D @types/node
       ```

    3. Create `src/middleware.ts` using Clerk's clerkMiddleware (NOT the deprecated authMiddleware). Protect all routes except /sign-in, /sign-up, /api/webhooks/clerk:
       ```typescript
       import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server';
       const isPublicRoute = createRouteMatcher(['/sign-in(.*)', '/sign-up(.*)', '/api/webhooks(.*)']);
       export default clerkMiddleware(async (auth, request) => {
         if (!isPublicRoute(request)) { await auth.protect(); }
       });
       export const config = { matcher: ['/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)', '/(api|trpc)(.*)'] };
       ```

    4. Wrap `src/app/layout.tsx` with `<ClerkProvider>` from `@clerk/nextjs`. Include `<html lang="en"><body>{children}</body></html>` structure.

    5. Create sign-in page at `src/app/(auth)/sign-in/[[...sign-in]]/page.tsx` using Clerk's `<SignIn />` component centered on the page.

    6. Create sign-up page at `src/app/(auth)/sign-up/[[...sign-up]]/page.tsx` using Clerk's `<SignUp />` component centered on the page.

    7. Create protected dashboard group layout `src/app/(dashboard)/layout.tsx` — no additional logic needed beyond the middleware protection.

    8. Create placeholder `src/app/(dashboard)/dashboard/page.tsx` that renders "Dashboard — Phase 1 coming soon" with the user's email from `useUser()`.

    9. Create Clerk webhook handler `src/app/api/webhooks/clerk/route.ts`:
       - Import Webhook from 'svix'
       - Verify webhook signature using CLERK_WEBHOOK_SECRET env var
       - On `user.created` event: upsert user in DB via prisma.user.upsert({ where: { clerkId }, create: { clerkId, email, name }, update: { email, name } })
       - Return 200 on success, 400 on signature failure

    10. Create `.env.example` with:
        ```
        NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_...
        CLERK_SECRET_KEY=sk_test_...
        CLERK_WEBHOOK_SECRET=whsec_...
        DATABASE_URL=postgresql://user:password@localhost:5432/realestate
        NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
        NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
        NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/dashboard
        NEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL=/dashboard
        ```

    NOTE: Use Clerk's pre-built components — do NOT build custom auth flows. This is per research recommendation to avoid 2-week auth rabbit hole.
  </action>
  <verify>
    1. `npm run dev` starts without errors
    2. Navigate to http://localhost:3000 — redirects to /sign-in
    3. Navigate to http://localhost:3000/dashboard without auth — redirects to /sign-in
    4. Sign up with test email — lands on /dashboard showing "Dashboard — Phase 1 coming soon"
    5. Refresh page — session persists
    6. Click sign out — redirects to /sign-in
    7. `npm run build` completes without TypeScript errors
  </verify>
  <done>
    - Unauthenticated users are redirected to /sign-in from any protected route
    - Authenticated users reach /dashboard after sign-in
    - Session persists across page refresh
    - Sign-out clears session and redirects to /sign-in
    - Password reset available via Clerk's built-in "Forgot password" link on sign-in page
  </done>
</task>

<task type="auto">
  <name>Task 2: Design and migrate the complete Phase 1 database schema</name>
  <files>
    prisma/schema.prisma
    src/lib/db.ts
    prisma/migrations/
  </files>
  <action>
    Create `prisma/schema.prisma` with the complete schema for all Phase 1 entities. Run `npx prisma migrate dev --name init`.

    **Schema Design Principles (from RESEARCH.md):**
    - Denormalize userId (clerk-synced internal UUID) on every table for multi-tenant isolation
    - TCPA-first: compliance tables are APPEND-ONLY (no soft deletes on contact_logs)
    - PostgreSQL enums for deal status (state machine)
    - JSONB for flexible fields (distress_signals, custom_fields, stage_history)
    - Immutable timestamps: created_at on audit tables, no updated_at

    **Full schema to implement:**

    ```prisma
    generator client {
      provider = "prisma-client-js"
    }

    datasource db {
      provider = "postgresql"
      url      = env("DATABASE_URL")
    }

    enum DealStatus {
      SOURCED
      ANALYZING
      QUALIFIED
      REJECTED
      UNDER_CONTRACT
      CLOSED
    }

    enum ContactMethod {
      EMAIL
      CALL
      SMS
      LETTER
    }

    enum ConsentStatus {
      NO_CONSENT_OBTAINED
      EXPRESS_WRITTEN_CONSENT
      PRIOR_EXPRESS_CONSENT
      DO_NOT_CALL
    }

    enum RuleType {
      FILTER
      SCORE_COMPONENT
    }

    enum Operator {
      GT
      LT
      EQ
      IN
      CONTAINS
      RANGE
      NOT_CONTAINS
    }

    enum KbCategory {
      ANALYSIS
      COMPLIANCE
      FORMULAS
      MARKET_TRENDS
      CREATIVE_FINANCE
    }

    model User {
      id        String   @id @default(uuid())
      clerkId   String   @unique
      email     String   @unique
      name      String?
      createdAt DateTime @default(now())
      updatedAt DateTime @updatedAt
      deletedAt DateTime?

      deals               Deal[]
      qualificationRules  QualificationRule[]
      contactLogs         ContactLog[]
      kbAccessLogs        KbAccessLog[]
      dealHistories       DealHistory[]
    }

    model Property {
      id                String    @id @default(uuid())
      externalId        String    @unique
      address           String
      city              String
      state             String
      zip               String
      latitude          Float?
      longitude         Float?
      propertyType      String?
      estimatedValue    Float?
      lastSalePrice     Float?
      lastSaleDate      DateTime?
      taxAssessedValue  Float?
      ownershipName     String?
      ownershipPhone    String?   // encrypted at app layer
      distressSignals   Json      @default("{}")
      dataSource        String    @default("CSV")
      dataFreshnessDate DateTime
      rawData           Json      @default("{}")
      createdAt         DateTime  @default(now())
      updatedAt         DateTime  @updatedAt

      deals       Deal[]
      contactLogs ContactLog[]

      @@index([address, city, state])
      @@index([dataFreshnessDate])
      @@index([externalId])
    }

    model Deal {
      id               String     @id @default(uuid())
      propertyId       String
      userId           String
      title            String
      status           DealStatus @default(SOURCED)
      stageHistory     Json       @default("[]")
      customFields     Json       @default("{}")
      qualificationScore Int      @default(0)
      estimatedProfit  Float?
      notes            String?
      pipelinePosition Int        @default(0)
      closedDate       DateTime?
      createdAt        DateTime   @default(now())
      updatedAt        DateTime   @updatedAt

      property    Property      @relation(fields: [propertyId], references: [id])
      user        User          @relation(fields: [userId], references: [id])
      history     DealHistory[]
      ruleEvals   RuleEvaluationLog[]

      @@index([userId, status])
      @@index([userId, pipelinePosition])
    }

    model DealHistory {
      id           String   @id @default(uuid())
      dealId       String
      userId       String
      fieldChanged String
      oldValue     String?
      newValue     String?
      createdAt    DateTime @default(now())  // IMMUTABLE — no updatedAt

      deal Deal @relation(fields: [dealId], references: [id])
      user User @relation(fields: [userId], references: [id])

      @@index([dealId, createdAt])
    }

    model ContactLog {
      id                    String        @id @default(uuid())
      propertyId            String
      userId                String
      ownerPhoneEncrypted   String?
      contactTimestamp      DateTime
      contactMethod         ContactMethod
      consentStatus         ConsentStatus
      consentTimestamp      DateTime?
      consentMedium         String?
      consentDetails        Json          @default("{}")
      optOutRequestedAt     DateTime?
      optOutProcessedAt     DateTime?
      callRecordingUrl      String?
      notes                 String?
      createdAt             DateTime      @default(now())  // IMMUTABLE — no updatedAt

      property Property @relation(fields: [propertyId], references: [id])
      user     User     @relation(fields: [userId], references: [id])

      @@index([propertyId])
      @@index([userId, contactTimestamp])
    }

    model ConsentRecord {
      id                       String    @id @default(uuid())
      ownerPhoneEncrypted      String
      originalConsentTimestamp DateTime
      originalConsentMethod    String
      disclosuresAcknowledged  Json      @default("[]")
      revocationTimestamp      DateTime?
      revocationMethod         String?
      revocationProcessedDate  DateTime?
      complianceStatus         String    @default("COMPLIANT")
      mustRetainUntil          DateTime
      createdAt                DateTime  @default(now())
      updatedAt                DateTime  @updatedAt

      @@index([ownerPhoneEncrypted])
    }

    model DoNotCallEntry {
      id              String    @id @default(uuid())
      phoneEncrypted  String    @unique
      addedReason     String
      expiryDate      DateTime?
      createdAt       DateTime  @default(now())

      @@index([phoneEncrypted])
    }

    model QualificationRule {
      id          String    @id @default(uuid())
      userId      String?   // null = system default rule
      name        String
      description String?
      ruleType    RuleType
      fieldName   String
      operator    Operator
      value       Json
      weight      Int       @default(0)
      enabled     Boolean   @default(true)
      createdAt   DateTime  @default(now())
      updatedAt   DateTime  @updatedAt

      user          User?               @relation(fields: [userId], references: [id])
      evaluations   RuleEvaluationLog[]

      @@index([userId, enabled])
    }

    model RuleEvaluationLog {
      id               String   @id @default(uuid())
      dealId           String
      ruleId           String
      evaluationResult String
      scoreAwarded     Int      @default(0)
      evaluatedAt      DateTime @default(now())

      deal Deal              @relation(fields: [dealId], references: [id])
      rule QualificationRule @relation(fields: [ruleId], references: [id])

      @@index([dealId])
    }

    model KbArticle {
      id          String     @id @default(uuid())
      title       String
      slug        String     @unique
      category    KbCategory
      content     String
      isPublished Boolean    @default(false)
      viewCount   Int        @default(0)
      createdAt   DateTime   @default(now())
      updatedAt   DateTime   @updatedAt

      accessLogs KbAccessLog[]

      @@index([slug])
      @@index([category])
      @@index([isPublished])
    }

    model KbAccessLog {
      id        String   @id @default(uuid())
      articleId String
      userId    String
      viewedAt  DateTime @default(now())

      article KbArticle @relation(fields: [articleId], references: [id])
      user    User      @relation(fields: [userId], references: [id])
    }
    ```

    After writing schema, run:
    ```bash
    npx prisma generate
    npx prisma migrate dev --name init
    ```

    Create `src/lib/db.ts` as Prisma singleton (prevents connection exhaustion in Next.js dev hot reload):
    ```typescript
    import { PrismaClient } from '@prisma/client';

    const globalForPrisma = globalThis as unknown as { prisma: PrismaClient };

    export const prisma = globalForPrisma.prisma ?? new PrismaClient({
      log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
    });

    if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
    ```
  </action>
  <verify>
    1. `npx prisma migrate status` shows migration applied cleanly
    2. `npx prisma studio` opens and shows all tables: User, Property, Deal, DealHistory, ContactLog, ConsentRecord, DoNotCallEntry, QualificationRule, RuleEvaluationLog, KbArticle, KbAccessLog
    3. `npx prisma db push --dry-run` shows no pending changes (schema in sync)
    4. `npm run build` passes TypeScript checks on db.ts
    5. Verify DealStatus enum includes: SOURCED, ANALYZING, QUALIFIED, REJECTED, UNDER_CONTRACT, CLOSED
  </verify>
  <done>
    - All 11 tables exist in PostgreSQL
    - DealStatus PostgreSQL enum enforces state machine values
    - ContactLog has no updatedAt (APPEND-ONLY design for TCPA compliance)
    - DealHistory has no updatedAt (immutable audit log)
    - prisma singleton in src/lib/db.ts exports `prisma`
    - Migration history committed to source control
  </done>
</task>

</tasks>

<verification>
1. `npm run dev` — app runs, unauthenticated hits /sign-in
2. Create test account via sign-up page — reaches /dashboard
3. Refresh — session persists
4. Log out — returns to /sign-in
5. `npx prisma studio` — all 11 tables visible with correct columns
6. Check ContactLog table has NO `updatedAt` column (TCPA compliance: append-only)
7. Check DealStatus enum values are correct
8. `npm run build` — zero TypeScript errors
</verification>

<success_criteria>
- Clerk authentication working end-to-end (sign-up, sign-in, session persistence, sign-out, password reset via email)
- All protected routes redirect unauthenticated users to /sign-in
- PostgreSQL database has all 11 Phase 1 tables from schema
- TCPA-critical tables (ContactLog, DealHistory) are append-only in design (no updatedAt)
- Prisma client generates without errors
- Next.js build passes TypeScript checks
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-deal-sourcing-crm/01-01-SUMMARY.md`
</output>
