---
phase: 01-core-deal-sourcing-crm
plan: "02"
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/lib/propstream/client.ts
  - src/lib/propstream/types.ts
  - src/lib/propstream/csvParser.ts
  - src/lib/propstream/searchFilters.ts
  - src/app/api/properties/search/route.ts
  - src/app/api/properties/import/route.ts
  - src/app/api/search-filters/route.ts
  - prisma/seed.ts
autonomous: true
requirements:
  - DS-01
  - DS-02
  - DS-03
  - DS-04
  - DS-05
  - DS-06
  - DS-07

must_haves:
  truths:
    - "User can import properties from a PropStream CSV export file"
    - "User can search imported properties filtered by days-on-market (e.g., 60-90 days)"
    - "User can filter properties by equity percentage (e.g., equity > 30%)"
    - "User can filter properties by debt owed (e.g., debt < $200k)"
    - "User can filter properties by interest rate (e.g., rate < 5%)"
    - "User can save a named search filter and retrieve it later"
    - "Filtered property list shows key metrics: address, estimated value, equity %, days listed, data freshness date"
  artifacts:
    - path: "src/lib/propstream/client.ts"
      provides: "PropStream API abstraction layer (API key auth if available, CSV fallback)"
      exports: ["PropStreamClient"]
    - path: "src/lib/propstream/csvParser.ts"
      provides: "CSV import parser that maps PropStream export columns to Property model"
      exports: ["parsePropStreamCsv"]
    - path: "src/lib/propstream/searchFilters.ts"
      provides: "Filter builder that converts UI filter criteria to Prisma WHERE clause"
      exports: ["buildPropertyFilter"]
    - path: "src/app/api/properties/search/route.ts"
      provides: "GET /api/properties/search?filters=... returns filtered Property[]"
      exports: ["GET"]
    - path: "src/app/api/properties/import/route.ts"
      provides: "POST /api/properties/import accepting CSV file, returns import summary"
      exports: ["POST"]
    - path: "src/app/api/search-filters/route.ts"
      provides: "CRUD for saved search filters"
      exports: ["GET", "POST", "DELETE"]
  key_links:
    - from: "src/lib/propstream/csvParser.ts"
      to: "prisma.property"
      via: "parsePropStreamCsv maps CSV rows to Property upsert via externalId"
      pattern: "prisma\\.property\\.upsert"
    - from: "src/app/api/properties/search/route.ts"
      to: "src/lib/propstream/searchFilters.ts"
      via: "buildPropertyFilter converts query params to WHERE clause"
      pattern: "buildPropertyFilter"
---

<objective>
Implement the property data layer: PropStream CSV import (primary path), API abstraction layer (future API path), property search with filters, and saved filter criteria.

Purpose: This is the core data intake pipeline. PropStream does not have a public API (requires partnership negotiation), so Phase 1 uses CSV export from PropStream's UI as the primary import path. The abstraction layer allows swapping to live API once partnership is secured without changing downstream code.

Output: Working import pipeline that ingests PropStream CSV exports, stores properties in PostgreSQL, and supports filtered search by time-on-market, equity, debt, and interest rate. Saved filters persist across sessions.
</objective>

<execution_context>
@/Users/jakezebe/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakezebe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-deal-sourcing-crm/01-RESEARCH.md
@.planning/phases/01-core-deal-sourcing-crm/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: PropStream data layer — CSV parser and API abstraction</name>
  <files>
    src/lib/propstream/types.ts
    src/lib/propstream/csvParser.ts
    src/lib/propstream/client.ts
    src/lib/propstream/searchFilters.ts
  </files>
  <action>
    **Context:** PropStream has no public API (partnership required per RESEARCH.md). Primary data path is CSV export from PropStream UI. Build an abstraction so when API becomes available, only `client.ts` changes — not the calling code.

    **1. Create `src/lib/propstream/types.ts`:**
    Define shared types for the PropStream data pipeline:
    ```typescript
    export interface PropStreamProperty {
      externalId: string;          // PropStream property ID (from CSV column "Property ID" or address hash)
      address: string;
      city: string;
      state: string;
      zip: string;
      propertyType?: string;
      estimatedValue?: number;     // ARV/estimated value
      lastSalePrice?: number;
      lastSaleDate?: Date;
      taxAssessedValue?: number;
      ownershipName?: string;
      ownershipPhone?: string;     // Will be encrypted before storage
      equity?: number;             // Equity % (0-100)
      debtOwed?: number;           // Total liens
      interestRate?: number;       // Current mortgage rate
      daysOnMarket?: number;
      distressSignals?: Record<string, boolean>;  // foreclosure, auction, preforeclosure, etc.
      dataFreshnessDate: Date;
      rawData?: Record<string, unknown>;
    }

    export interface PropertySearchFilters {
      minDaysOnMarket?: number;
      maxDaysOnMarket?: number;
      minEquityPercent?: number;
      maxEquityPercent?: number;
      maxDebtOwed?: number;
      maxInterestRate?: number;
      city?: string;
      state?: string;
      propertyType?: string;
    }

    export interface SavedSearchFilter {
      id: string;
      name: string;
      filters: PropertySearchFilters;
    }

    export interface ImportResult {
      totalRows: number;
      imported: number;
      updated: number;
      skipped: number;
      errors: string[];
    }
    ```

    **2. Create `src/lib/propstream/csvParser.ts`:**
    Parse PropStream CSV export format. PropStream CSV exports typically use these column headers (map flexibly):
    - "Property ID" or first address hash as externalId
    - "Property Address", "City", "State", "Zip"
    - "Estimated Value", "Last Sale Price", "Last Sale Date"
    - "Equity Percent", "Open Liens Amount", "Mortgage Interest Rate"
    - "Days On Market", "Owner Name", "Owner Phone"
    - Distress columns: "In Foreclosure", "Pre-Foreclosure", "Auction Date", etc.

    Use `papaparse` for CSV parsing (install: `npm install papaparse @types/papaparse`).

    Key implementation details:
    - Map column headers case-insensitively (PropStream column names vary slightly between exports)
    - Generate externalId from address string if "Property ID" column not present: `${address}_${city}_${state}_${zip}`
    - Parse numeric fields defensively (empty string → undefined, not 0)
    - Set dataFreshnessDate to import timestamp
    - Store raw row in rawData JSONB field (never delete original)
    - Encrypt ownershipPhone using Node.js `crypto.createCipheriv` with AES-256-GCM before saving:
      ```typescript
      // Use ENCRYPTION_KEY env var (32 bytes). Store iv + authTag + encrypted as base64 JSON
      function encryptPhone(phone: string): string { ... }
      ```

    Export `parsePropStreamCsv(csvString: string): PropStreamProperty[]`

    **3. Create `src/lib/propstream/client.ts`:**
    API abstraction layer — today returns CSV-imported data; tomorrow calls PropStream live API:
    ```typescript
    export class PropStreamClient {
      // For Phase 1: only searchProperties is used (reads from DB)
      // When API available: this class gets a real implementation
      async searchProperties(filters: PropertySearchFilters): Promise<PropStreamProperty[]> {
        // Phase 1: delegate to DB query (properties imported via CSV)
        // Phase 2: call PropStream partner API
        throw new Error('Use /api/properties/search endpoint for DB-backed search');
      }
    }
    ```
    This establishes the pattern without blocking anything.

    **4. Create `src/lib/propstream/searchFilters.ts`:**
    Convert `PropertySearchFilters` to a Prisma `where` clause:
    ```typescript
    import { Prisma } from '@prisma/client';
    import { PropertySearchFilters } from './types';

    export function buildPropertyFilter(filters: PropertySearchFilters): Prisma.PropertyWhereInput {
      const where: Prisma.PropertyWhereInput = {};
      // daysOnMarket: stored as part of distressSignals JSONB or as a separate computed value
      // For Phase 1 MVP, store daysOnMarket in rawData and query via JSON path
      if (filters.minEquityPercent !== undefined) {
        // equity is stored in rawData.equity — use Prisma JSON path filter
        // OR: add equity as a typed column on Property (preferred for queryability)
        // Decision: Add equity, debtOwed, interestRate, daysOnMarket as columns to Property
        // (Update schema if needed, then filter here)
      }
      return where;
    }
    ```

    NOTE: If equity/debt/interest/daysOnMarket are not in the initial schema as typed columns, add them to `prisma/schema.prisma` and run a migration. These MUST be typed columns (not JSONB) for efficient filtering.
  </action>
  <verify>
    1. `npx tsc --noEmit` passes on all files in src/lib/propstream/
    2. Unit test with sample CSV string: `parsePropStreamCsv(sampleCsv)` returns array with correct fields
    3. `buildPropertyFilter({ minEquityPercent: 30, maxDebtOwed: 200000 })` returns valid Prisma WHERE clause (no runtime errors)
    4. ownershipPhone encryption produces base64 string (not plain text)
  </verify>
  <done>
    - parsePropStreamCsv maps all standard PropStream CSV columns to PropStreamProperty type
    - Phone numbers are encrypted (AES-256-GCM) before any storage
    - buildPropertyFilter generates valid Prisma WHERE clauses for all 5 filter dimensions
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Property import and search API routes + saved filters</name>
  <files>
    src/app/api/properties/import/route.ts
    src/app/api/properties/search/route.ts
    src/app/api/search-filters/route.ts
    prisma/schema.prisma
  </files>
  <action>
    **Schema update first:** If equity/debt/interestRate/daysOnMarket are not typed columns, add to Property model and migrate:
    ```prisma
    model Property {
      // ... existing fields ...
      equityPercent    Float?
      debtOwed         Float?
      interestRate     Float?
      daysOnMarket     Int?
    }
    ```
    Run: `npx prisma migrate dev --name add-filter-columns`

    **1. Create `src/app/api/properties/import/route.ts`:**
    POST endpoint accepting multipart/form-data with CSV file:
    - Extract auth via `auth()` from `@clerk/nextjs/server`, get userId, look up internal User
    - Parse uploaded file as text, pass to `parsePropStreamCsv()`
    - Upsert each property via `prisma.property.upsert({ where: { externalId }, create: {...}, update: {...} })`
    - Return ImportResult JSON: `{ totalRows, imported, updated, skipped, errors }`
    - Limit: accept up to 10,000 rows per import (return 413 if exceeded)
    - Do NOT create deals automatically — just store properties

    **2. Create `src/app/api/properties/search/route.ts`:**
    GET endpoint with query params for all filter dimensions:
    - Query params: `minDays`, `maxDays`, `minEquity`, `maxDebt`, `maxRate`, `city`, `state`, `filterId`
    - If `filterId` provided: load saved filter criteria from DB, merge with any additional params
    - Build WHERE clause via `buildPropertyFilter()`
    - Always include `where: { userId: internalUserId }` — NEVER query without user scoping
    - Return properties with: id, address, city, state, zip, estimatedValue, equityPercent, debtOwed, interestRate, daysOnMarket, dataFreshnessDate, distressSignals
    - Add data freshness warning flag: `{ isStale: dataFreshnessDate < (now - 14 days) }` per RESEARCH.md
    - Paginate: default 50/page, max 200/page, return `{ properties, total, page, hasMore }`

    **3. Create `src/app/api/search-filters/route.ts`:**
    CRUD for saved filter criteria (DS-06):
    - GET: returns all saved filters for authenticated user
    - POST: saves new filter `{ name, filters: PropertySearchFilters }` — validate name length 1-100 chars, validate filter fields are valid types (use Zod)
    - DELETE `/api/search-filters/[id]`: deletes filter owned by user (verify ownership before delete)

    Store saved filters in a new `SavedSearchFilter` model. Add to prisma/schema.prisma:
    ```prisma
    model SavedSearchFilter {
      id        String   @id @default(uuid())
      userId    String
      name      String
      filters   Json
      createdAt DateTime @default(now())
      updatedAt DateTime @updatedAt

      user User @relation(fields: [userId], references: [id])

      @@index([userId])
    }
    ```
    Run migration: `npx prisma migrate dev --name add-saved-filters`

    **Validation with Zod** for POST /api/search-filters:
    ```typescript
    const SavedFilterSchema = z.object({
      name: z.string().min(1).max(100),
      filters: z.object({
        minDaysOnMarket: z.number().min(0).optional(),
        maxDaysOnMarket: z.number().min(0).optional(),
        minEquityPercent: z.number().min(0).max(100).optional(),
        maxEquityPercent: z.number().min(0).max(100).optional(),
        maxDebtOwed: z.number().min(0).optional(),
        maxInterestRate: z.number().min(0).max(100).optional(),
        city: z.string().optional(),
        state: z.string().length(2).optional(),
      }),
    });
    ```
  </action>
  <verify>
    1. `curl -X POST http://localhost:3000/api/properties/import -F "file=@test.csv" -H "Authorization: Bearer test"` — returns `{ totalRows, imported, updated, skipped, errors }`
    2. `curl "http://localhost:3000/api/properties/search?minEquity=30&maxDebt=200000"` — returns paginated property list
    3. `curl -X POST http://localhost:3000/api/search-filters -d '{"name":"Test Filter","filters":{"minEquityPercent":30}}'` — returns saved filter with ID
    4. `curl http://localhost:3000/api/search-filters` — returns list of saved filters
    5. Properties without user scoping return 0 results (tenant isolation working)
    6. `npm run build` TypeScript passes
  </verify>
  <done>
    - POST /api/properties/import accepts CSV file, returns import summary with row counts
    - GET /api/properties/search accepts minDays, maxDays, minEquity, maxDebt, maxRate query params and returns filtered, paginated property list
    - Property response includes `isStale` flag when data is older than 14 days
    - GET/POST/DELETE /api/search-filters provide full CRUD for saved filters
    - All endpoints require authentication and scope queries to authenticated user's data
  </done>
</task>

</tasks>

<verification>
1. Import a real PropStream CSV export (or sample data) — properties appear in DB
2. Search with equity filter — only matching properties returned
3. Search with debt filter — only properties below debt threshold returned
4. Search with days-on-market filter — correct results
5. Save a filter, retrieve it by ID, use it in search
6. Delete a filter — gone from list
7. Verify property response includes: address, city, state, estimatedValue, equityPercent, debtOwed, interestRate, daysOnMarket, dataFreshnessDate, isStale
8. Query another user's properties — returns empty (multi-tenant isolation)
</verification>

<success_criteria>
- CSV import ingests PropStream export files and upserts properties with encrypted phone numbers
- Property search filters work for all 5 dimensions: days-on-market, equity %, debt owed, interest rate, geographic
- Data freshness date shown and stale flag set for data older than 14 days
- Saved filters can be created, listed, retrieved by ID, and deleted
- All API endpoints are authenticated and user-scoped (no cross-tenant data leakage)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-deal-sourcing-crm/01-02-SUMMARY.md`
</output>
