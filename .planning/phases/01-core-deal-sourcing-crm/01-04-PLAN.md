---
phase: 01-core-deal-sourcing-crm
plan: "04"
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/app/api/deals/route.ts
  - src/app/api/deals/[id]/route.ts
  - src/app/api/deals/[id]/transition/route.ts
  - src/lib/deals/stateMachine.ts
  - src/lib/deals/types.ts

autonomous: true
requirements:
  - TC-01
  - TC-02

must_haves:
  truths:
    - "User can create a deal from an imported property"
    - "User can view all their deals organized by pipeline stage"
    - "User can move a deal from one pipeline stage to another (valid transitions only)"
    - "Invalid stage transitions are rejected with an error (e.g., cannot go CLOSED → ANALYZING)"
    - "Every deal status change is recorded in DealHistory with timestamp and user ID"
    - "User can view full stage history for any deal"
  artifacts:
    - path: "src/lib/deals/stateMachine.ts"
      provides: "Deal state machine — valid transitions, enforcement, audit logging"
      exports: ["VALID_TRANSITIONS", "canTransition", "transitionDeal"]
    - path: "src/lib/deals/types.ts"
      provides: "DealState enum, DealTransition interface, CreateDealInput type"
      exports: ["DealState", "DealTransition", "CreateDealInput"]
    - path: "src/app/api/deals/route.ts"
      provides: "GET /api/deals (list by status) and POST /api/deals (create from property)"
      exports: ["GET", "POST"]
    - path: "src/app/api/deals/[id]/route.ts"
      provides: "GET /api/deals/:id (detail with history), PATCH /api/deals/:id (update notes/fields)"
      exports: ["GET", "PATCH"]
    - path: "src/app/api/deals/[id]/transition/route.ts"
      provides: "POST /api/deals/:id/transition — enforces state machine, writes DealHistory"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/deals/[id]/transition/route.ts"
      to: "src/lib/deals/stateMachine.ts"
      via: "calls transitionDeal() which validates and executes state change"
      pattern: "transitionDeal"
    - from: "src/lib/deals/stateMachine.ts"
      to: "prisma.dealHistory"
      via: "writes immutable history record for every transition"
      pattern: "prisma\\.dealHistory\\.create"
---

<objective>
Implement the Deal CRM backend: deal creation from properties, the state machine enforcing valid transitions (SOURCED → ANALYZING → QUALIFIED → REJECTED/UNDER_CONTRACT → CLOSED), and full pipeline stage history.

Purpose: TC-01 and TC-02 require deals to be organized in a visual pipeline with tracked stages. This plan builds the data layer and transition logic that the UI (Plan 06) will consume. The state machine is the authority on valid transitions — no free-form status changes.

Output: Working Deal CRUD API with state machine enforcement, full DealHistory audit trail per deal, and pipeline query endpoint that groups deals by stage.
</objective>

<execution_context>
@/Users/jakezebe/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakezebe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-deal-sourcing-crm/01-RESEARCH.md
@.planning/phases/01-core-deal-sourcing-crm/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Deal state machine and TypeScript types</name>
  <files>
    src/lib/deals/types.ts
    src/lib/deals/stateMachine.ts
  </files>
  <action>
    **Context:** The CRM pipeline requires strict state machine enforcement. From RESEARCH.md, the valid transitions are:
    SOURCED → ANALYZING, SOURCED → REJECTED
    ANALYZING → QUALIFIED, ANALYZING → REJECTED
    QUALIFIED → UNDER_CONTRACT, QUALIFIED → REJECTED
    UNDER_CONTRACT → CLOSED, UNDER_CONTRACT → REJECTED
    Terminal states: CLOSED and REJECTED (no exit without creating a new deal)

    **1. Create `src/lib/deals/types.ts`:**
    ```typescript
    import { DealStatus } from '@prisma/client';

    export type DealState = DealStatus; // SOURCED | ANALYZING | QUALIFIED | REJECTED | UNDER_CONTRACT | CLOSED

    export interface DealTransitionInput {
      dealId: string;
      targetState: DealState;
      userId: string;
      notes?: string;
      transitionData?: {
        estimatedProfit?: number;   // Required for UNDER_CONTRACT transition
        closedDate?: Date;          // Required for CLOSED transition
        rejectionReason?: string;   // Optional for REJECTED
      };
    }

    export interface TransitionResult {
      success: boolean;
      deal?: { id: string; status: DealState; updatedAt: Date };
      error?: string;
    }

    export interface CreateDealInput {
      propertyId: string;
      title: string;
      notes?: string;
    }

    export interface DealWithHistory {
      id: string;
      propertyId: string;
      userId: string;
      title: string;
      status: DealState;
      qualificationScore: number;
      estimatedProfit: number | null;
      notes: string | null;
      pipelinePosition: number;
      createdAt: Date;
      updatedAt: Date;
      property: {
        id: string;
        address: string;
        city: string;
        state: string;
        estimatedValue: number | null;
        equityPercent: number | null;
        dataFreshnessDate: Date;
      };
      history: Array<{
        id: string;
        fieldChanged: string;
        oldValue: string | null;
        newValue: string | null;
        createdAt: Date;
      }>;
    }
    ```

    **2. Create `src/lib/deals/stateMachine.ts`:**

    Define the valid transitions as a typed constant — this is the single source of truth:
    ```typescript
    import { DealStatus } from '@prisma/client';
    import { prisma } from '@/lib/db';
    import type { DealTransitionInput, TransitionResult } from './types';

    type ValidTransition = {
      from: DealStatus;
      to: DealStatus;
      requiredFields?: ('estimatedProfit' | 'closedDate')[];
    };

    export const VALID_TRANSITIONS: ValidTransition[] = [
      { from: 'SOURCED',        to: 'ANALYZING' },
      { from: 'SOURCED',        to: 'REJECTED' },
      { from: 'ANALYZING',      to: 'QUALIFIED' },
      { from: 'ANALYZING',      to: 'REJECTED' },
      { from: 'QUALIFIED',      to: 'UNDER_CONTRACT', requiredFields: ['estimatedProfit'] },
      { from: 'QUALIFIED',      to: 'REJECTED' },
      { from: 'UNDER_CONTRACT', to: 'CLOSED',         requiredFields: ['closedDate'] },
      { from: 'UNDER_CONTRACT', to: 'REJECTED' },
    ];

    export function canTransition(from: DealStatus, to: DealStatus): boolean {
      return VALID_TRANSITIONS.some(t => t.from === from && t.to === to);
    }

    export async function transitionDeal(input: DealTransitionInput): Promise<TransitionResult> {
      const { dealId, targetState, userId, notes, transitionData } = input;

      // Load deal with ownership check
      const deal = await prisma.deal.findFirst({
        where: { id: dealId, userId },
      });
      if (!deal) return { success: false, error: 'Deal not found or access denied' };

      // Validate transition
      const transition = VALID_TRANSITIONS.find(
        t => t.from === deal.status && t.to === targetState
      );
      if (!transition) {
        return {
          success: false,
          error: `Invalid transition: ${deal.status} → ${targetState}. Valid next states: ${
            VALID_TRANSITIONS.filter(t => t.from === deal.status).map(t => t.to).join(', ') || 'none (terminal state)'
          }`,
        };
      }

      // Check required fields
      if (transition.requiredFields) {
        const missing = transition.requiredFields.filter(
          f => transitionData?.[f] === undefined || transitionData[f] === null
        );
        if (missing.length > 0) {
          return { success: false, error: `Missing required fields for this transition: ${missing.join(', ')}` };
        }
      }

      // Execute transition in transaction: update deal + write DealHistory
      const updateData: Record<string, unknown> = { status: targetState };
      if (transitionData?.estimatedProfit !== undefined) updateData.estimatedProfit = transitionData.estimatedProfit;
      if (transitionData?.closedDate !== undefined) updateData.closedDate = transitionData.closedDate;

      await prisma.$transaction([
        prisma.deal.update({ where: { id: dealId }, data: updateData }),
        prisma.dealHistory.create({
          data: {
            dealId,
            userId,
            fieldChanged: 'status',
            oldValue: deal.status,
            newValue: targetState,
          },
        }),
        // Log notes change if provided
        ...(notes ? [prisma.dealHistory.create({
          data: { dealId, userId, fieldChanged: 'notes', oldValue: deal.notes, newValue: notes },
        })] : []),
      ]);

      const updatedDeal = await prisma.deal.findUnique({ where: { id: dealId } });
      return { success: true, deal: updatedDeal ? { id: updatedDeal.id, status: updatedDeal.status as DealState, updatedAt: updatedDeal.updatedAt } : undefined };
    }
    ```
  </action>
  <verify>
    1. `npx tsc --noEmit` passes on src/lib/deals/ files
    2. canTransition('SOURCED', 'ANALYZING') returns true
    3. canTransition('CLOSED', 'ANALYZING') returns false
    4. canTransition('SOURCED', 'CLOSED') returns false (must go through ANALYZING)
    5. All valid transition pairs in VALID_TRANSITIONS match the state machine diagram in RESEARCH.md
  </verify>
  <done>
    - VALID_TRANSITIONS array captures all 8 valid state transitions
    - canTransition() returns correct boolean for all tested pairs
    - transitionDeal() writes DealHistory atomically with deal.status update (Prisma transaction)
    - transitionDeal() returns descriptive error for invalid transitions listing valid next states
    - UNDER_CONTRACT transition requires estimatedProfit, CLOSED requires closedDate — enforced
  </done>
</task>

<task type="auto">
  <name>Task 2: Deal CRUD API endpoints</name>
  <files>
    src/app/api/deals/route.ts
    src/app/api/deals/[id]/route.ts
    src/app/api/deals/[id]/transition/route.ts
  </files>
  <action>
    All endpoints require Clerk authentication. Extract userId from `auth()` and look up internal User.id via `prisma.user.findUnique({ where: { clerkId: userId } })`. Never expose data from other users.

    **1. Create `src/app/api/deals/route.ts`:**

    GET /api/deals — returns deals grouped by pipeline stage:
    - Query param `status`: filter by specific DealStatus (optional)
    - Query param `page` + `limit` (default 50): pagination
    - Always scope to `where: { userId: internalUser.id }`
    - Include property (address, city, state, estimatedValue, equityPercent, dataFreshnessDate) and most recent history entry
    - Return shape:
      ```json
      {
        "pipeline": {
          "SOURCED": [...deals],
          "ANALYZING": [...deals],
          "QUALIFIED": [...deals],
          "UNDER_CONTRACT": [...deals],
          "CLOSED": [...deals],
          "REJECTED": [...deals]
        },
        "total": 42
      }
      ```
    - If `status` param provided: return flat `{ deals, total, page, hasMore }` instead of grouped

    POST /api/deals — create deal from property:
    - Body: `{ propertyId: string, title: string, notes?: string }`
    - Validate with Zod: title 1-200 chars, propertyId must exist and belong to no existing active deal (prevent duplicate deal for same property)
    - Create with status: SOURCED, qualificationScore: 0, pipelinePosition: count of existing SOURCED deals
    - Write initial DealHistory entry: `{ fieldChanged: 'status', oldValue: null, newValue: 'SOURCED' }`
    - Return 201 with created deal

    **2. Create `src/app/api/deals/[id]/route.ts`:**

    GET /api/deals/:id — returns deal detail:
    - Include full property data + full DealHistory ordered by createdAt ASC
    - Include ruleEvals (RuleEvaluationLog) if qualification has been run
    - Return 404 if deal not found or owned by different user

    PATCH /api/deals/:id — update mutable fields:
    - Allowed fields: `notes`, `pipelinePosition`, `customFields`, `title`
    - Do NOT allow updating `status` via PATCH — use /transition endpoint instead
    - For each changed field, write DealHistory entry (oldValue → newValue)
    - Return updated deal

    **3. Create `src/app/api/deals/[id]/transition/route.ts`:**

    POST /api/deals/:id/transition — state machine transition:
    - Body: `{ targetState: DealStatus, notes?: string, transitionData?: { estimatedProfit?, closedDate?, rejectionReason? } }`
    - Validate targetState is a valid DealStatus enum value
    - Call `transitionDeal({ dealId: id, targetState, userId: internalUser.id, notes, transitionData })` from stateMachine.ts
    - On success: return 200 with updated deal
    - On failure: return 422 with `{ error: string }` (not 400 — the request was valid, the transition is not)
  </action>
  <verify>
    1. POST /api/deals with valid propertyId → 201 with deal in SOURCED status
    2. GET /api/deals → returns pipeline object with SOURCED array containing the new deal
    3. POST /api/deals/:id/transition { targetState: "ANALYZING" } → 200, deal now in ANALYZING
    4. POST /api/deals/:id/transition { targetState: "SOURCED" } (regression) → 422 with error message
    5. POST /api/deals/:id/transition { targetState: "UNDER_CONTRACT" } without estimatedProfit → 422 with "Missing required fields" error
    6. GET /api/deals/:id → includes history array with 2 entries (creation + ANALYZING transition)
    7. Different user's token trying GET /api/deals/:id → 404 (not 403, to avoid leaking existence)
    8. `npm run build` passes TypeScript
  </verify>
  <done>
    - GET /api/deals returns deals grouped by pipeline stage (TC-01: pipeline view)
    - POST /api/deals creates deal in SOURCED state with initial DealHistory entry
    - POST /api/deals/:id/transition enforces state machine — invalid transitions return 422 with explanation
    - UNDER_CONTRACT requires estimatedProfit, CLOSED requires closedDate
    - GET /api/deals/:id returns full DealHistory (TC-02: stage tracking)
    - All endpoints scope queries to authenticated user — cross-user access returns 404
  </done>
</task>

</tasks>

<verification>
1. Create a deal from a property: POST /api/deals → 201, status SOURCED
2. Check pipeline view: GET /api/deals → deal appears in pipeline.SOURCED array
3. Transition to ANALYZING: POST /api/deals/:id/transition { targetState: "ANALYZING" } → 200
4. Check history: GET /api/deals/:id → history has SOURCED + ANALYZING entries
5. Invalid transition: POST /api/deals/:id/transition { targetState: "CLOSED" } from ANALYZING → 422 with error
6. Try UNDER_CONTRACT without estimatedProfit → 422 "Missing required fields: estimatedProfit"
7. Transition ANALYZING → QUALIFIED (requires plan 03 qualification to set score, but transition itself works)
8. Full pipeline populated: all 6 DealStatus stages represented in GET /api/deals response
</verification>

<success_criteria>
- Deal creation from property ID works, starts in SOURCED state
- GET /api/deals returns all deals grouped by DealStatus stage (TC-01 data layer)
- State machine enforces valid transitions — every invalid attempt returns 422 with explanation
- Every stage change recorded in DealHistory with userId, oldValue, newValue, timestamp (TC-02)
- UNDER_CONTRACT transition requires estimatedProfit; CLOSED requires closedDate
- All endpoints are user-scoped — other users' deals return 404, not 403
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-deal-sourcing-crm/01-04-SUMMARY.md`
</output>
