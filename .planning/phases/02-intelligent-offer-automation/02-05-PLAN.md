---
phase: 02-intelligent-offer-automation
plan: "05"
type: execute
wave: 2
depends_on:
  - "01-02"
files_modified:
  - src/lib/enrichment/reiskip.ts
  - src/lib/enrichment/types.ts
  - src/app/api/contacts/enrich/route.ts
  - src/app/api/contacts/bulk-enrich/route.ts
  - .env.example
autonomous: true
requirements:
  - AU-04

must_haves:
  truths:
    - "User can enrich a single property contact (phone/email lookup via skip-trace)"
    - "System bulk enriches 50+ properties in one batch operation"
    - "Enriched contact data (phone, email) stored in Property.ownershipPhone (encrypted)"
    - "Failed enrichments logged but don't stop batch operation"
    - "User can trigger enrichment before bulk sending offers (prepares contact list)"
  artifacts:
    - path: "src/lib/enrichment/types.ts"
      provides: "Contact enrichment response types"
      exports: ["EnrichmentResult", "BulkEnrichmentResponse"]
    - path: "src/lib/enrichment/reiskip.ts"
      provides: "REISkip skip-trace integration (default, Phase 2) and BatchData integration scaffold"
      exports: ["enrichContact", "bulkEnrichContacts"]
    - path: "src/app/api/contacts/enrich/route.ts"
      provides: "POST /api/contacts/enrich for single contact enrichment"
      exports: ["POST"]
    - path: "src/app/api/contacts/bulk-enrich/route.ts"
      provides: "POST /api/contacts/bulk-enrich for batch enrichment"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/contacts/bulk-enrich/route.ts"
      to: "src/lib/enrichment/reiskip.ts"
      via: "bulkEnrichContacts processes property batch"
      pattern: "bulkEnrichContacts"
    - from: "src/lib/enrichment/reiskip.ts"
      to: "prisma.property"
      via: "Updates Property.ownershipPhone with enriched phone (encrypted)"
      pattern: "prisma\\.property\\.update"

user_setup:
  - service: reiskip
    why: "Skip-trace service for phone/email lookup ($0.15/record)"
    env_vars:
      - name: REISKIP_API_KEY
        source: "REISkip Dashboard -> API Keys"
    dashboard_config:
      - task: "Create API key"
        location: "REISkip -> Settings -> API Keys"
      - task: "Verify account has credits"
        location: "REISkip -> Billing -> Check balance"

---

<objective>
Integrate contact enrichment (skip-trace) to look up phone/email from property owner names. REISkip is default Phase 2 provider. BatchData optional for Phase 2.1.

Purpose: Users can send offers without manual contact lookup. System enriches property owner info at scale, preparing for bulk send.

Output: Working contact enrichment endpoints (single + bulk), integration with REISkip API, encrypted phone storage.
</objective>

<execution_context>
@/Users/jakezebe/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakezebe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-intelligent-offer-automation/02-CONTEXT.md
@.planning/phases/02-intelligent-offer-automation/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: REISkip integration and contact enrichment library</name>
  <files>
    src/lib/enrichment/types.ts
    src/lib/enrichment/reiskip.ts
  </files>
  <action>
    **1. Create `src/lib/enrichment/types.ts`:**
    ```typescript
    export interface EnrichmentResult {
      propertyId: string;
      ownerName?: string;
      ownerPhone?: string;
      ownerEmail?: string;
      success: boolean;
      provider: 'reiskip' | 'batchdata';
      cost: number;
      error?: string;
    }

    export interface BulkEnrichmentResponse {
      total: number;
      enriched: number;
      failed: number;
      totalCost: number;
      results: EnrichmentResult[];
    }

    export interface REISkipResponse {
      success: boolean;
      data?: {
        phone?: string;
        email?: string;
        name?: string;
      };
      error?: string;
    }
    ```

    **2. Create `src/lib/enrichment/reiskip.ts`:**
    ```typescript
    import { prisma } from '@/lib/db';
    import { encryptPhone } from '@/lib/encryption'; // Use existing encryption from Phase 1
    import type { EnrichmentResult } from './types';

    const REISKIP_API_KEY = process.env.REISKIP_API_KEY;
    const REISKIP_BASE_URL = 'https://api.reiskip.com/v1';

    if (!REISKIP_API_KEY) {
      console.warn('REISKIP_API_KEY not set â€” enrichment will fail');
    }

    /**
     * Enrich a single property contact via REISkip
     * Lookup phone/email from owner name and address
     */
    export async function enrichContact(
      propertyId: string,
      ownerName: string,
      address: string,
      city: string,
      state: string,
      zip: string
    ): Promise<EnrichmentResult> {
      if (!REISKIP_API_KEY) {
        return {
          propertyId,
          success: false,
          provider: 'reiskip',
          cost: 0,
          error: 'REISKIP_API_KEY not configured',
        };
      }

      try {
        const response = await fetch(\`\${REISKIP_BASE_URL}/skip-trace\`, {
          method: 'POST',
          headers: {
            'Authorization': \`Bearer \${REISKIP_API_KEY}\`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            ownerName,
            address,
            city,
            state,
            zip,
          }),
        });

        if (!response.ok) {
          return {
            propertyId,
            success: false,
            provider: 'reiskip',
            cost: 0.15, // Standard REISkip cost
            error: \`REISkip API error: \${response.status}\`,
          };
        }

        const data = await response.json();

        if (!data.success) {
          return {
            propertyId,
            success: false,
            provider: 'reiskip',
            cost: 0.15,
            error: data.error || 'REISkip lookup failed',
          };
        }

        // Store enriched data
        const updateData: any = {};

        if (data.data?.phone) {
          updateData.ownershipPhone = encryptPhone(data.data.phone);
        }

        if (data.data?.email) {
          // Store email if available (add field in Phase 2.1)
        }

        if (Object.keys(updateData).length > 0) {
          await prisma.property.update({
            where: { id: propertyId },
            data: updateData,
          });
        }

        return {
          propertyId,
          ownerName: data.data?.name,
          ownerPhone: data.data?.phone,
          ownerEmail: data.data?.email,
          success: true,
          provider: 'reiskip',
          cost: 0.15,
        };
      } catch (error: any) {
        console.error(\`REISkip enrichment error for \${propertyId}:\`, error);
        return {
          propertyId,
          success: false,
          provider: 'reiskip',
          cost: 0.15,
          error: error.message || 'Enrichment failed',
        };
      }
    }

    /**
     * Bulk enrich properties
     * Process in serial to respect API rate limits
     */
    export async function bulkEnrichContacts(
      propertyIds: string[]
    ): Promise<EnrichmentResult[]> {
      const results: EnrichmentResult[] = [];

      const properties = await prisma.property.findMany({
        where: { id: { in: propertyIds } },
        select: {
          id: true,
          address: true,
          city: true,
          state: true,
          zip: true,
          ownershipName: true,
          ownershipPhone: true,
        },
      });

      for (const property of properties) {
        // Skip if already has phone
        if (property.ownershipPhone) {
          results.push({
            propertyId: property.id,
            success: true,
            provider: 'reiskip',
            cost: 0,
            error: 'Already enriched',
          });
          continue;
        }

        if (!property.ownershipName) {
          results.push({
            propertyId: property.id,
            success: false,
            provider: 'reiskip',
            cost: 0,
            error: 'Missing owner name',
          });
          continue;
        }

        const result = await enrichContact(
          property.id,
          property.ownershipName,
          property.address,
          property.city,
          property.state,
          property.zip
        );

        results.push(result);

        // Rate limit: wait 100ms between requests
        await new Promise((resolve) => setTimeout(resolve, 100));
      }

      return results;
    }
    ```
  </action>
  <verify>
    1. enrichContact() calls REISkip API with owner name and address
    2. Successful enrichment updates Property.ownershipPhone (encrypted)
    3. enrichContact() returns EnrichmentResult with success/cost/error fields
    4. bulkEnrichContacts() processes array of propertyIds
    5. Bulk enrichment respects rate limits (100ms between requests)
    6. Already-enriched properties skipped with cost = 0
    7. Build passes TypeScript checks
  </verify>
  <done>
    - REISkip API integration implemented with Bearer token auth
    - enrichContact() handles single property lookup
    - bulkEnrichContacts() processes batch with rate limiting
    - Phone number encrypted before storage
    - Results tracked with cost accounting ($0.15 per successful lookup)
    - Error handling for missing owner names and API failures
  </done>
</task>

<task type="auto">
  <name>Task 2: Single and bulk enrichment endpoints</name>
  <files>
    src/app/api/contacts/enrich/route.ts
    src/app/api/contacts/bulk-enrich/route.ts
  </files>
  <action>
    **1. Create `src/app/api/contacts/enrich/route.ts`:**
    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { auth } from '@clerk/nextjs/server';
    import { prisma } from '@/lib/db';
    import { enrichContact } from '@/lib/enrichment/reiskip';
    import { z } from 'zod';

    const enrichSchema = z.object({
      propertyId: z.string().uuid(),
    });

    export async function POST(req: NextRequest) {
      const { userId } = await auth();

      if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const body = await req.json();
        const { propertyId } = enrichSchema.parse(body);

        const property = await prisma.property.findUnique({
          where: { id: propertyId },
        });

        if (!property) {
          return NextResponse.json(
            { error: 'Property not found' },
            { status: 404 }
          );
        }

        if (!property.ownershipName) {
          return NextResponse.json(
            { error: 'Property missing owner name' },
            { status: 400 }
          );
        }

        const result = await enrichContact(
          property.id,
          property.ownershipName,
          property.address,
          property.city,
          property.state,
          property.zip
        );

        return NextResponse.json({ result });
      } catch (error: any) {
        if (error instanceof z.ZodError) {
          return NextResponse.json(
            { error: 'Invalid input', details: error.errors },
            { status: 400 }
          );
        }
        console.error('Enrich contact error:', error);
        return NextResponse.json(
          { error: 'Enrichment failed' },
          { status: 500 }
        );
      }
    }
    ```

    **2. Create `src/app/api/contacts/bulk-enrich/route.ts`:**
    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { auth } from '@clerk/nextjs/server';
    import { prisma } from '@/lib/db';
    import { bulkEnrichContacts } from '@/lib/enrichment/reiskip';
    import { z } from 'zod';

    const bulkEnrichSchema = z.object({
      propertyIds: z.array(z.string().uuid()).min(1).max(100),
    });

    export async function POST(req: NextRequest) {
      const { userId } = await auth();

      if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const body = await req.json();
        const { propertyIds } = bulkEnrichSchema.parse(body);

        // Verify user owns these properties (via deals)
        const properties = await prisma.property.findMany({
          where: {
            id: { in: propertyIds },
            deals: {
              some: {
                userId,
              },
            },
          },
          select: { id: true },
        });

        if (properties.length === 0) {
          return NextResponse.json(
            { error: 'No valid properties found' },
            { status: 404 }
          );
        }

        const results = await bulkEnrichContacts(
          properties.map((p) => p.id)
        );

        const totalCost = results.reduce((sum, r) => sum + r.cost, 0);
        const enriched = results.filter((r) => r.success).length;

        return NextResponse.json({
          success: true,
          results: {
            total: results.length,
            enriched,
            failed: results.length - enriched,
            totalCost,
            results,
          },
        });
      } catch (error: any) {
        if (error instanceof z.ZodError) {
          return NextResponse.json(
            { error: 'Invalid input', details: error.errors },
            { status: 400 }
          );
        }
        console.error('Bulk enrich error:', error);
        return NextResponse.json(
          { error: 'Bulk enrichment failed' },
          { status: 500 }
        );
      }
    }
    ```
  </action>
  <verify>
    1. POST /api/contacts/enrich returns EnrichmentResult for single property
    2. POST /api/contacts/bulk-enrich processes 50+ properties in one request
    3. Both endpoints verify user authorization (via deal ownership)
    4. Missing propertyId returns 400
    5. Invalid propertyId returns 404
    6. Response includes total cost and success count
    7. Failed enrichments don't stop batch operation
    8. Build passes TypeScript checks
  </verify>
  <done>
    - POST /api/contacts/enrich enriches single property contact
    - POST /api/contacts/bulk-enrich enriches multiple properties (max 100)
    - Results tracked with cost and success metrics
    - User authorization verified via deal ownership
    - Error handling for missing owner names and API failures
    - Batch operation continues on individual failures
  </done>
</task>

</tasks>

<verification>
1. REISkip API integration functional with Bearer token auth
2. enrichContact() calls API and updates Property.ownershipPhone
3. bulkEnrichContacts() processes batch with rate limiting
4. Phone numbers encrypted before storage
5. Cost tracking ($0.15 per successful lookup)
6. Endpoints properly authorize via deal ownership
7. Build passes TypeScript checks
</verification>

<success_criteria>
- REISkip skip-trace integration implemented
- POST /api/contacts/enrich enriches single property
- POST /api/contacts/bulk-enrich enriches 50+ properties in batch
- Enriched phone numbers stored encrypted in Property.ownershipPhone
- Results include success count, failure count, total cost
- Already-enriched properties skipped (cost = 0)
- Missing owner names handled gracefully
- User authorization verified on all endpoints
</success_criteria>

<output>
After completion, create `.planning/phases/02-intelligent-offer-automation/02-05-SUMMARY.md`
</output>
