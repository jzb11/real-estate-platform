---
phase: 02-intelligent-offer-automation
plan: "04"
type: execute
wave: 2
depends_on:
  - "01-03"
files_modified:
  - prisma/schema.prisma
  - src/lib/qualification/engine.ts
  - src/lib/qualification/creativeFinance.ts
  - src/app/api/rules/creative-finance/route.ts
autonomous: true
requirements:
  - QA-06
  - QA-07

must_haves:
  truths:
    - "User can create a custom creative finance rule (e.g., 'flag as Subject-To if property type = investment AND equity < 40%')"
    - "Creative finance rules extend Phase 1 rules engine without breaking existing FILTER/SCORE rules"
    - "Deals matching creative finance criteria are marked with CREATIVE_FINANCE flag and +20 score bonus"
    - "Pipeline shows creative finance deals with badge (e.g., 'Subject-To', 'Seller Finance')"
    - "Sorting by qualification_score now correctly ranks creative finance deals higher"
    - "User can enable/disable creative finance rules individually"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "QualificationRule extended with ruleSubtype field for creative finance rule types"
      contains: "ruleSubtype String?"
    - path: "src/lib/qualification/creativeFinance.ts"
      provides: "Creative finance rule evaluation and bonus scoring logic"
      exports: ["evaluateCreativeFinanceRule", "CREATIVE_FINANCE_RULES"]
    - path: "src/lib/qualification/engine.ts"
      provides: "Extended evaluateDeal() to call creative finance rules after standard rules"
      exports: ["evaluateDeal", "calculateMAO"]
    - path: "src/app/api/rules/creative-finance/route.ts"
      provides: "CRUD endpoints for creative finance rules"
      exports: ["GET", "POST", "PUT", "DELETE"]
  key_links:
    - from: "src/lib/qualification/engine.ts"
      to: "src/lib/qualification/creativeFinance.ts"
      via: "evaluateDeal calls evaluateCreativeFinanceRule for each creative finance rule"
      pattern: "evaluateCreativeFinanceRule"
    - from: "src/app/api/rules/creative-finance/route.ts"
      to: "prisma.qualificationRule"
      via: "creates QualificationRule with ruleSubtype in ['SUBJECT_TO', 'SELLER_FINANCE', ...]"
      pattern: "prisma\\.qualificationRule\\.create"

---

<objective>
Extend Phase 1 rules engine with creative finance deal identification. New rule type identifies subject-to, seller financing, and lease-option deals. Rules add +20 score bonus and mark deals with CREATIVE_FINANCE flag.

Purpose: Creative finance deals are highest-ROI opportunities but hard to identify manually. Automating detection unlocks the core product differentiator. Extends Phase 1 without breaking existing workflow.

Output: Working creative finance rule types, extended evaluateDeal() logic, CRUD API for managing CF rules.
</objective>

<execution_context>
@/Users/jakezebe/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakezebe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-intelligent-offer-automation/02-CONTEXT.md
@.planning/phases/02-intelligent-offer-automation/02-RESEARCH.md
@.planning/phases/01-core-deal-sourcing-crm/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend schema with creative finance rule types</name>
  <files>
    prisma/schema.prisma
  </files>
  <action>
    Add enum to `prisma/schema.prisma` BEFORE the QualificationRule model:

    ```prisma
    enum CreativeFinanceType {
      SUBJECT_TO
      SELLER_FINANCE
      OWNER_OCCUPIED_VACATED
      LEASE_OPTION
      BRRRR
      WHOLESALE
      LAND_CONTRACT
      RENT_TO_OWN
    }
    ```

    Add field to QualificationRule model:

    ```prisma
    model QualificationRule {
      id          String    @id @default(uuid())
      userId      String?
      name        String
      description String?
      ruleType    RuleType
      fieldName   String
      operator    Operator
      value       Json
      weight      Int       @default(0)
      ruleSubtype CreativeFinanceType?  // NEW: identifies CF rule type
      enabled     Boolean   @default(true)
      createdAt   DateTime  @default(now())
      updatedAt   DateTime  @updatedAt

      user          User?               @relation(fields: [userId], references: [id])
      evaluations   RuleEvaluationLog[]

      @@index([userId, enabled, ruleSubtype])
    }
    ```

    Run migration:
    ```bash
    npx prisma migrate dev --name add_creative_finance_rules
    ```
  </action>
  <verify>
    1. Migration applied cleanly
    2. QualificationRule table has ruleSubtype column (nullable)
    3. CreativeFinanceType enum created in PostgreSQL
    4. Index on (userId, enabled, ruleSubtype) created for filtering CF rules
    5. Build passes TypeScript checks
  </verify>
  <done>
    - QualificationRule schema extended with ruleSubtype field
    - CreativeFinanceType enum enforces valid CF deal types
    - Index on ruleSubtype enables efficient rule filtering
    - Migration committed to source control
  </done>
</task>

<task type="auto">
  <name>Task 2: Creative finance evaluation logic</name>
  <files>
    src/lib/qualification/creativeFinance.ts
  </files>
  <action>
    Create `src/lib/qualification/creativeFinance.ts`. This module evaluates properties against creative finance rules.

    ```typescript
    import { CreativeFinanceType } from '@prisma/client';
    import { evaluateOperator } from './operators';
    import type { Property, QualificationRule } from '@prisma/client';
    import _ from 'lodash';

    export const CREATIVE_FINANCE_RULES: Record<CreativeFinanceType, string> = {
      SUBJECT_TO: 'Property with existing mortgage (subject-to finance opportunity)',
      SELLER_FINANCE: 'Owner willing to finance (seller carry-back opportunity)',
      OWNER_OCCUPIED_VACATED: 'Owner-occupied or recently vacated (less competition)',
      LEASE_OPTION: 'Property suitable for lease-option strategy',
      BRRRR: 'Property suitable for Buy-Renovate-Rent-Refinance-Repeat',
      WHOLESALE: 'Property suitable for wholesaling (high discount needed)',
      LAND_CONTRACT: 'Property suitable for land contract (no traditional financing)',
      RENT_TO_OWN: 'Property suitable for rent-to-own strategy',
    };

    export interface CreativeFinanceResult {
      type: CreativeFinanceType;
      matched: boolean;
      scoreBonus: number;
      explanation: string;
    }

    /**
     * Evaluate property against a creative finance rule
     * Returns true if property matches the rule criteria
     */
    export function evaluateCreativeFinanceRule(
      property: Property,
      rule: QualificationRule & { ruleSubtype: CreativeFinanceType | null }
    ): CreativeFinanceResult | null {
      if (!rule.ruleSubtype) {
        return null; // Not a CF rule
      }

      try {
        // Evaluate the rule's filter condition
        const fieldValue = _.get(property, rule.fieldName);
        const ruleValue = rule.value as any;

        const matched = evaluateOperator(fieldValue, rule.operator as any, ruleValue);

        return {
          type: rule.ruleSubtype,
          matched,
          scoreBonus: matched ? 20 : 0, // +20 points for matching CF deals
          explanation: matched
            ? \`Property matches \${rule.name}: \${CREATIVE_FINANCE_RULES[rule.ruleSubtype]}\`
            : \`Property does not match \${rule.name}\`,
        };
      } catch (error) {
        console.error('Creative finance rule evaluation error:', error);
        return {
          type: rule.ruleSubtype,
          matched: false,
          scoreBonus: 0,
          explanation: 'Rule evaluation failed',
        };
      }
    }

    /**
     * Evaluate all creative finance rules for a property
     * Returns matched CF types and total score bonus
     */
    export function evaluateAllCreativeFinanceRules(
      property: Property,
      rules: Array<QualificationRule & { ruleSubtype: CreativeFinanceType | null }>
    ) {
      const cfRules = rules.filter((r) => r.ruleSubtype && r.enabled);

      const results = cfRules
        .map((rule) => evaluateCreativeFinanceRule(property, rule))
        .filter((result) => result !== null) as CreativeFinanceResult[];

      const matchedTypes = results
        .filter((r) => r.matched)
        .map((r) => r.type);

      const totalBonus = results.reduce((sum, r) => sum + r.scoreBonus, 0);

      return {
        matched: matchedTypes.length > 0,
        matchedTypes,
        totalBonus,
        results,
      };
    }
    ```
  </action>
  <verify>
    1. evaluateCreativeFinanceRule() returns CreativeFinanceResult with matched/scoreBonus/explanation
    2. evaluateAllCreativeFinanceRules() sums bonus from all matching CF rules
    3. Score bonus is +20 per matched CF rule
    4. Non-CF rules (ruleSubtype = null) are skipped
    5. Build passes TypeScript checks
  </verify>
  <done>
    - evaluateCreativeFinanceRule() evaluates property against single CF rule
    - evaluateAllCreativeFinanceRules() aggregates all CF rule matches
    - Score bonus: +20 per matched CF deal
    - Explanation strings capture rule match details
    - Integration-ready for Phase 1 engine.ts extension
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend Phase 1 engine and add CF rule API</name>
  <files>
    src/lib/qualification/engine.ts
    src/app/api/rules/creative-finance/route.ts
  </files>
  <action>
    **1. Update `src/lib/qualification/engine.ts`:**
    Import and call CF evaluation. Update the evaluateDeal function:

    ```typescript
    // At top of file, add import:
    import { evaluateAllCreativeFinanceRules } from './creativeFinance';

    // Inside evaluateDeal function, after standard SCORE_COMPONENT rules are evaluated,
    // add creative finance scoring:

    // ... existing SCORE_COMPONENT rule evaluation ...

    // Evaluate creative finance rules (adds bonus score)
    const creativeFinanceEval = evaluateAllCreativeFinanceRules(property, rules);
    qualificationScore += creativeFinanceEval.totalBonus;

    // Mark deal with creative finance flag if matched
    const creativeFinanceFlag = creativeFinanceEval.matched
      ? creativeFinanceEval.matchedTypes
      : null;

    return {
      // ... existing return object fields ...
      qualificationScore,
      creativeFinanceTypes: creativeFinanceFlag, // NEW field
      creativeFinanceEvaluation: creativeFinanceEval, // NEW field for debugging
    };
    ```

    **2. Create `src/app/api/rules/creative-finance/route.ts`:**
    CRUD endpoints for creative finance rules.

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { auth } from '@clerk/nextjs/server';
    import { prisma } from '@/lib/db';
    import { z } from 'zod';
    import { CreativeFinanceType } from '@prisma/client';

    const createCFRuleSchema = z.object({
      name: z.string().min(1).max(100),
      description: z.string().optional(),
      fieldName: z.string().min(1),
      operator: z.enum(['GT', 'LT', 'EQ', 'IN', 'CONTAINS', 'RANGE', 'NOT_CONTAINS']),
      value: z.any(),
      ruleSubtype: z.enum([
        'SUBJECT_TO',
        'SELLER_FINANCE',
        'OWNER_OCCUPIED_VACATED',
        'LEASE_OPTION',
        'BRRRR',
        'WHOLESALE',
        'LAND_CONTRACT',
        'RENT_TO_OWN',
      ]),
    });

    export async function GET(req: NextRequest) {
      const { userId } = await auth();

      if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const rules = await prisma.qualificationRule.findMany({
          where: {
            userId,
            ruleSubtype: { not: null }, // Only CF rules
          },
          select: {
            id: true,
            name: true,
            description: true,
            fieldName: true,
            operator: true,
            value: true,
            ruleSubtype: true,
            enabled: true,
            createdAt: true,
          },
          orderBy: { createdAt: 'desc' },
        });

        return NextResponse.json({ rules });
      } catch (error) {
        console.error('Fetch CF rules error:', error);
        return NextResponse.json(
          { error: 'Failed to fetch rules' },
          { status: 500 }
        );
      }
    }

    export async function POST(req: NextRequest) {
      const { userId } = await auth();

      if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const body = await req.json();
        const parsed = createCFRuleSchema.parse(body);

        const rule = await prisma.qualificationRule.create({
          data: {
            userId,
            name: parsed.name,
            description: parsed.description,
            ruleType: 'SCORE_COMPONENT',
            fieldName: parsed.fieldName,
            operator: parsed.operator as any,
            value: parsed.value,
            ruleSubtype: parsed.ruleSubtype as CreativeFinanceType,
            weight: 0,
            enabled: true,
          },
        });

        return NextResponse.json({ rule }, { status: 201 });
      } catch (error: any) {
        if (error instanceof z.ZodError) {
          return NextResponse.json(
            { error: 'Invalid input', details: error.errors },
            { status: 400 }
          );
        }
        console.error('Create CF rule error:', error);
        return NextResponse.json(
          { error: 'Failed to create rule' },
          { status: 500 }
        );
      }
    }

    export async function PUT(req: NextRequest) {
      const { userId } = await auth();

      if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const body = await req.json();
        const { ruleId, ...updateData } = body;

        // Verify ownership
        const rule = await prisma.qualificationRule.findUnique({
          where: { id: ruleId },
        });

        if (!rule || rule.userId !== userId) {
          return NextResponse.json({ error: 'Rule not found' }, { status: 404 });
        }

        const updated = await prisma.qualificationRule.update({
          where: { id: ruleId },
          data: updateData,
        });

        return NextResponse.json({ rule: updated });
      } catch (error) {
        console.error('Update CF rule error:', error);
        return NextResponse.json(
          { error: 'Failed to update rule' },
          { status: 500 }
        );
      }
    }

    export async function DELETE(req: NextRequest) {
      const { userId } = await auth();

      if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const { ruleId } = await req.json();

        // Verify ownership
        const rule = await prisma.qualificationRule.findUnique({
          where: { id: ruleId },
        });

        if (!rule || rule.userId !== userId) {
          return NextResponse.json({ error: 'Rule not found' }, { status: 404 });
        }

        await prisma.qualificationRule.delete({
          where: { id: ruleId },
        });

        return NextResponse.json({ success: true });
      } catch (error) {
        console.error('Delete CF rule error:', error);
        return NextResponse.json(
          { error: 'Failed to delete rule' },
          { status: 500 }
        );
      }
    }
    ```
  </action>
  <verify>
    1. evaluateDeal() now includes creativeFinanceTypes and creativeFinanceEvaluation in return
    2. Creative finance score bonus (+20 per matched type) added to qualificationScore
    3. GET /api/rules/creative-finance returns array of user's CF rules
    4. POST /api/rules/creative-finance creates new CF rule with ruleSubtype
    5. PUT /api/rules/creative-finance/[id] updates rule (enabled/disabled)
    6. DELETE /api/rules/creative-finance/[id] deletes rule
    7. CF rules don't interfere with Phase 1 FILTER rules (same RuleType enum)
    8. Build passes TypeScript checks
  </verify>
  <done>
    - evaluateDeal() extended to call evaluateAllCreativeFinanceRules()
    - Creative finance deals get +20 score bonus per matched type
    - creativeFinanceTypes field in evaluateDeal response shows matched types
    - GET /api/rules/creative-finance returns user's CF rules
    - POST creates CF rule with ruleSubtype (SUBJECT_TO, SELLER_FINANCE, etc.)
    - PUT enables/disables CF rules
    - DELETE removes CF rule
    - All endpoints verify userId ownership
  </done>
</task>

</tasks>

<verification>
1. Schema extended with CreativeFinanceType enum and ruleSubtype field
2. Creative finance evaluation logic in place (+20 bonus per matched type)
3. Phase 1 engine.ts extended to call CF evaluation
4. CF rules don't break existing FILTER/SCORE rules
5. API endpoints functional for CF rule CRUD
6. Deals correctly marked with creative finance flag
7. Score calculation includes CF bonus
8. Build passes TypeScript checks
</verification>

<success_criteria>
- QualificationRule schema extended with ruleSubtype field (nullable)
- CreativeFinanceType enum enforces valid CF deal types
- evaluateCreativeFinanceRule() evaluates property against CF criteria
- evaluateAllCreativeFinanceRules() aggregates all matches and returns +20 bonus per matched type
- evaluateDeal() returns creativeFinanceTypes array when CF rules matched
- POST /api/rules/creative-finance creates CF rule with validation
- CF rules don't interfere with Phase 1 FILTER/SCORE rules
- Deals with CF matches get score boost and flag for UI display
</success_criteria>

<output>
After completion, create `.planning/phases/02-intelligent-offer-automation/02-04-SUMMARY.md`
</output>
