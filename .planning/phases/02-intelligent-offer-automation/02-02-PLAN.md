---
phase: 02-intelligent-offer-automation
plan: "02"
type: execute
wave: 1
depends_on:
  - "02-01"
files_modified:
  - src/lib/queue/bullmq.ts
  - src/lib/queue/jobs.ts
  - src/app/api/sequences/route.ts
  - src/app/api/sequences/[id]/route.ts
  - src/lib/automation/sequenceExecutor.ts
  - package.json
autonomous: true
requirements:
  - AU-01
  - AU-02
  - AU-03

must_haves:
  truths:
    - "User can create a follow-up sequence template (email → wait 3 days → email → wait 7 days → SMS)"
    - "When user sends an offer, system automatically enqueues the follow-up sequence for that recipient"
    - "Follow-up jobs execute on schedule via BullMQ (Redis-backed job queue)"
    - "User can pause/resume a follow-up sequence for a specific deal"
    - "Each follow-up step is logged immutably to FollowUpEvent table with timestamp, status, content"
    - "Failed jobs are retried with exponential backoff"
  artifacts:
    - path: "src/lib/queue/bullmq.ts"
      provides: "BullMQ queue setup and job handlers"
      exports: ["followUpQueue", "registerJobHandlers"]
    - path: "src/lib/queue/jobs.ts"
      provides: "Job payload types and enqueueing functions"
      exports: ["enqueueFollowUpSequence", "FollowUpJobPayload"]
    - path: "src/lib/automation/sequenceExecutor.ts"
      provides: "Core logic to execute a sequence step (send email, wait, send SMS)"
      exports: ["executeSequenceStep"]
    - path: "src/app/api/sequences/route.ts"
      provides: "CRUD endpoints for follow-up sequence templates"
      exports: ["GET", "POST", "PUT", "DELETE"]
    - path: "src/app/api/sequences/[id]/route.ts"
      provides: "Sequence detail and pause/resume endpoints"
      exports: ["GET", "PATCH"]
  key_links:
    - from: "src/lib/queue/jobs.ts"
      to: "src/lib/queue/bullmq.ts"
      via: "enqueueFollowUpSequence adds job to followUpQueue"
      pattern: "followUpQueue\\.add"
    - from: "src/lib/queue/bullmq.ts"
      to: "src/lib/automation/sequenceExecutor.ts"
      via: "Job handler calls executeSequenceStep for each job"
      pattern: "executeSequenceStep"
    - from: "src/lib/automation/sequenceExecutor.ts"
      to: "prisma.followUpEvent"
      via: "Logs every step execution to FollowUpEvent (immutable audit trail)"
      pattern: "prisma\\.followUpEvent\\.create"

---

<objective>
Build the job queue infrastructure for automated follow-up sequences. BullMQ (Redis-backed) handles reliable job scheduling and retry logic. Sequence executor executes individual steps (send email, wait, send SMS) with full audit logging.

Purpose: Users define sequences once, system handles reliability at scale. Jobs persist in Redis, survive server restarts, retry on failure, and don't require background services.

Output: A working BullMQ queue with sequence job handlers, sequence template CRUD API, and pause/resume controls.
</objective>

<execution_context>
@/Users/jakezebe/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakezebe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-intelligent-offer-automation/02-CONTEXT.md
@.planning/phases/02-intelligent-offer-automation/02-RESEARCH.md
@.planning/phases/02-intelligent-offer-automation/02-01-SUMMARY.md
@.planning/phases/01-core-deal-sourcing-crm/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: BullMQ queue setup and job handlers</name>
  <files>
    package.json
    src/lib/queue/bullmq.ts
    src/lib/queue/jobs.ts
  </files>
  <action>
    **1. Install BullMQ:**
    ```bash
    npm install bullmq
    ```

    **2. Create `src/lib/queue/bullmq.ts`:**
    Initialize BullMQ queue with Redis connection (reuse Phase 1 Redis).

    ```typescript
    import { Queue, Worker, QueueEvents } from 'bullmq';
    import { executeSequenceStep } from '@/lib/automation/sequenceExecutor';

    // Use Redis URL from environment (same Redis as Phase 1 caching)
    const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';

    // Parse Redis URL to object format for BullMQ
    const redisConnection = parseRedisUrl(redisUrl);

    export const followUpQueue = new Queue('follow-up-sequences', {
      connection: redisConnection,
      defaultJobOptions: {
        attempts: 5, // Retry up to 5 times
        backoff: {
          type: 'exponential',
          delay: 2000, // Start at 2 seconds, exponential backoff
        },
        removeOnComplete: {
          age: 3600, // Keep completed jobs for 1 hour
        },
        removeOnFail: {
          age: 86400, // Keep failed jobs for 24 hours for debugging
        },
      },
    });

    const queueEvents = new QueueEvents('follow-up-sequences', {
      connection: redisConnection,
    });

    // Job handler — process one job at a time to avoid race conditions
    export const followUpWorker = new Worker(
      'follow-up-sequences',
      async (job) => {
        console.log(\`Processing follow-up job: \${job.id}\`);
        return executeSequenceStep(job.data);
      },
      {
        connection: redisConnection,
        concurrency: 1, // One job at a time
        lockDuration: 30000, // 30s lock
        lockRenewTime: 15000, // Renew every 15s
      }
    );

    // Event listeners for monitoring
    followUpWorker.on('failed', (job, err) => {
      console.error(\`Job \${job?.id} failed: \${err.message}\`);
      // Alert user via database flag if job exhausts retries
      if (job && job.attemptsStarted >= job.opts.attempts!) {
        // Mark sequence as FAILED in DB
        console.log(\`Job \${job.id} exhausted retries\`);
      }
    });

    followUpWorker.on('completed', (job) => {
      console.log(\`Job \${job.id} completed successfully\`);
    });

    queueEvents.on('failed', ({ jobId, failedReason }) => {
      console.error(\`Queue event: Job \${jobId} failed: \${failedReason}\`);
    });

    export async function registerJobHandlers() {
      // Handler already registered above via Worker
      console.log('BullMQ job handlers registered');
    }

    function parseRedisUrl(url: string): Record<string, any> {
      const parsed = new URL(url);
      return {
        host: parsed.hostname,
        port: parseInt(parsed.port || '6379', 10),
        password: parsed.password || undefined,
        db: parsed.pathname ? parseInt(parsed.pathname.slice(1), 10) : 0,
      };
    }

    // Graceful cleanup
    process.on('SIGTERM', async () => {
      console.log('Shutting down BullMQ worker...');
      await followUpWorker.close();
      await queueEvents.close();
      process.exit(0);
    });
    ```

    **3. Create `src/lib/queue/jobs.ts`:**
    Define job types and enqueueing functions.

    ```typescript
    import { followUpQueue } from './bullmq';
    import { prisma } from '@/lib/db';

    export interface FollowUpJobPayload {
      scheduledId: string;      // FollowUpScheduled.id
      dealId: string;
      userId: string;
      sequenceId: string;
      stepIndex: number;        // Which step in the sequence (0-indexed)
      recipientEmail: string;
      recipientName?: string;
      stepData: {
        type: 'EMAIL' | 'SMS' | 'WAIT';
        delayDays?: number;
        subject?: string;
        htmlContent?: string;
        plainText?: string;
        phoneNumber?: string;
      };
    }

    /**
     * Enqueue the next step of a follow-up sequence
     * Calculates delay based on step configuration
     */
    export async function enqueueFollowUpSequence(payload: FollowUpJobPayload) {
      const { stepData, stepIndex, scheduledId } = payload;

      let delayMs = 0;

      if (stepData.type === 'WAIT' && stepData.delayDays) {
        // Schedule this job to run X days from now
        delayMs = stepData.delayDays * 24 * 60 * 60 * 1000;
      } else if (stepData.type === 'EMAIL' || stepData.type === 'SMS') {
        // Execute immediately (but will be queued)
        delayMs = 0;
      }

      try {
        const job = await followUpQueue.add(
          'execute-step',
          payload,
          {
            delay: delayMs,
            jobId: \`\${scheduledId}-step-\${stepIndex}-\${Date.now()}\`,
          }
        );

        console.log(\`Enqueued follow-up job: \${job.id} (step \${stepIndex})\`);
        return job;
      } catch (error) {
        console.error('Failed to enqueue follow-up job:', error);
        throw error;
      }
    }

    /**
     * Schedule the entire sequence (enqueue first step, rest handled by executor)
     */
    export async function scheduleFollowUpSequence(
      scheduledId: string,
      dealId: string,
      userId: string,
      sequenceId: string,
      recipientEmail: string,
      recipientName: string | undefined
    ) {
      try {
        // Fetch sequence template
        const sequence = await prisma.followUpSequence.findUnique({
          where: { id: sequenceId },
        });

        if (!sequence) {
          throw new Error(\`Sequence \${sequenceId} not found\`);
        }

        const steps = sequence.steps as any[]; // JSON array of step objects

        if (steps.length === 0) {
          throw new Error('Sequence has no steps');
        }

        // Enqueue first step
        const firstStep = steps[0];
        await enqueueFollowUpSequence({
          scheduledId,
          dealId,
          userId,
          sequenceId,
          stepIndex: 0,
          recipientEmail,
          recipientName,
          stepData: firstStep,
        });

        return true;
      } catch (error) {
        console.error('Failed to schedule follow-up sequence:', error);
        throw error;
      }
    }
    ```
  </action>
  <verify>
    1. `npm run build` passes TypeScript checks
    2. Verify Redis URL is correctly parsed from REDIS_URL environment variable
    3. Verify followUpQueue exports with proper BullMQ configuration
    4. Verify job retries with exponential backoff (attempts: 5, delay: 2s exponential)
    5. Check that job handler calls executeSequenceStep
    6. Verify enqueueFollowUpSequence calculates delay correctly (WAIT steps scheduled days in future)
  </verify>
  <done>
    - BullMQ queue configured with Redis connection (reuses Phase 1 Redis)
    - Job handler registered and monitoring (failed/completed events logged)
    - Retry logic with exponential backoff (5 attempts, 2s → exponential)
    - Job persistence: completed kept 1 hour, failed kept 24 hours
    - Graceful shutdown handler for worker process
    - enqueueFollowUpSequence() with delay calculation for WAIT steps
    - scheduleFollowUpSequence() to enqueue entire sequence starting at step 0
  </done>
</task>

<task type="auto">
  <name>Task 2: Sequence executor and immutable event logging</name>
  <files>
    src/lib/automation/sequenceExecutor.ts
  </files>
  <action>
    Create `src/lib/automation/sequenceExecutor.ts`. This is the core logic that executes each step.

    ```typescript
    import { prisma } from '@/lib/db';
    import { sendOfferEmail } from '@/lib/email/sendgrid';
    import { renderOfferEmail } from '@/lib/email/offerTemplate';
    import { enqueueFollowUpSequence } from '@/lib/queue/jobs';
    import type { FollowUpJobPayload } from '@/lib/queue/jobs';

    /**
     * Execute one step of a follow-up sequence
     * Called by BullMQ job handler
     */
    export async function executeSequenceStep(payload: FollowUpJobPayload) {
      const {
        scheduledId,
        dealId,
        userId,
        sequenceId,
        stepIndex,
        recipientEmail,
        recipientName,
        stepData,
      } = payload;

      try {
        // Fetch sequence and scheduled instance to check status
        const scheduled = await prisma.followUpScheduled.findUnique({
          where: { id: scheduledId },
        });

        if (!scheduled) {
          throw new Error(\`FollowUpScheduled \${scheduledId} not found\`);
        }

        // Skip if paused or completed
        if (scheduled.status === 'PAUSED') {
          console.log(\`Sequence \${scheduledId} is paused, skipping step \${stepIndex}\`);
          return { skipped: true, reason: 'PAUSED' };
        }

        if (scheduled.status === 'COMPLETED') {
          console.log(\`Sequence \${scheduledId} is completed, skipping step \${stepIndex}\`);
          return { skipped: true, reason: 'COMPLETED' };
        }

        const sequence = await prisma.followUpSequence.findUnique({
          where: { id: sequenceId },
        });

        if (!sequence) {
          throw new Error(\`Sequence \${sequenceId} not found\`);
        }

        const steps = sequence.steps as any[];
        const nextStep = steps[stepIndex + 1];

        // Execute the step based on type
        let executionResult: any = {};
        let eventStatus = 'SUCCESS';

        try {
          switch (stepData.type) {
            case 'EMAIL':
              executionResult = await executeEmailStep(
                dealId,
                userId,
                recipientEmail,
                recipientName,
                stepData
              );
              break;

            case 'SMS':
              // SMS execution deferred to Phase 2.1 (Twilio integration)
              executionResult = {
                skipped: true,
                reason: 'SMS not implemented in Phase 2',
              };
              break;

            case 'WAIT':
              // WAIT steps don't execute; they're handled by job delay
              // Just log that we waited
              executionResult = {
                waited: true,
                delayDays: stepData.delayDays,
              };
              break;

            default:
              throw new Error(\`Unknown step type: \${stepData.type}\`);
          }
        } catch (error: any) {
          eventStatus = 'FAILED';
          executionResult.error = error.message;
        }

        // Log the event (immutable append-only)
        await prisma.followUpEvent.create({
          data: {
            scheduledId,
            sequenceId,
            stepIndex,
            eventType: getEventType(stepData.type, eventStatus),
            content: {
              type: stepData.type,
              subject: stepData.subject,
              status: eventStatus,
              executionResult,
            },
            status: eventStatus,
            failureReason: eventStatus === 'FAILED' ? executionResult.error : null,
            sentAt: new Date(),
          },
        });

        // Update FollowUpScheduled to next step
        if (eventStatus === 'SUCCESS' && nextStep) {
          // Enqueue next step
          await enqueueFollowUpSequence({
            scheduledId,
            dealId,
            userId,
            sequenceId,
            stepIndex: stepIndex + 1,
            recipientEmail,
            recipientName,
            stepData: nextStep,
          });

          // Update currentStep pointer
          await prisma.followUpScheduled.update({
            where: { id: scheduledId },
            data: {
              currentStep: stepIndex + 1,
              nextStepAt: calculateNextStepTime(nextStep),
            },
          });

          return { success: true, nextStepQueued: true };
        } else if (eventStatus === 'SUCCESS' && !nextStep) {
          // Sequence complete
          await prisma.followUpScheduled.update({
            where: { id: scheduledId },
            data: {
              status: 'COMPLETED',
              currentStep: stepIndex + 1,
            },
          });

          return { success: true, sequenceCompleted: true };
        } else {
          // Failed — job will retry via BullMQ
          throw new Error(\`Step execution failed: \${executionResult.error}\`);
        }
      } catch (error) {
        console.error('Sequence step execution error:', error);
        throw error;
      }
    }

    async function executeEmailStep(
      dealId: string,
      userId: string,
      recipientEmail: string,
      recipientName: string | undefined,
      stepData: any
    ) {
      // Fetch deal and property for context
      const deal = await prisma.deal.findUnique({
        where: { id: dealId },
        include: { property: true },
      });

      if (!deal || !deal.property) {
        throw new Error('Deal or property not found');
      }

      // For now, send predefined follow-up content
      // In Phase 2.1, this would support custom templates
      const subject = stepData.subject || 'Follow-up: Your Property Offer';
      const htmlContent = stepData.htmlContent || getDefaultFollowUpHtml(deal);
      const plainText = stepData.plainText || getDefaultFollowUpText(deal);

      // Send via SendGrid
      const sendResult = await sendOfferEmail(
        recipientEmail,
        recipientName,
        htmlContent,
        plainText,
        subject
      );

      return {
        sent: true,
        messageId: sendResult.messageId,
        statusCode: sendResult.statusCode,
      };
    }

    function getEventType(stepType: string, status: string): string {
      if (status === 'FAILED') return 'EMAIL_FAILED';

      switch (stepType) {
        case 'EMAIL':
          return 'EMAIL_SENT';
        case 'SMS':
          return 'SMS_SENT';
        case 'WAIT':
          return 'WAIT_COMPLETED';
        default:
          return 'UNKNOWN';
      }
    }

    function calculateNextStepTime(nextStep: any): Date {
      const now = new Date();
      if (nextStep.type === 'WAIT' && nextStep.delayDays) {
        now.setDate(now.getDate() + nextStep.delayDays);
      }
      return now;
    }

    function getDefaultFollowUpHtml(deal: any): string {
      return \`
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        body { font-family: Arial, sans-serif; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
      </style>
    </head>
    <body>
      <div class="container">
        <h2>Follow-up: Professional Offer</h2>
        <p>We wanted to follow up on our recent offer for:</p>
        <p><strong>\${deal.property.address}</strong></p>
        <p>If you have any questions or would like to discuss, please don't hesitate to reach out.</p>
        <p>We're ready to move forward quickly.</p>
      </div>
    </body>
    </html>
      \`;
    }

    function getDefaultFollowUpText(deal: any): string {
      return \`
    Follow-up: Professional Offer

    We wanted to follow up on our recent offer for:

    \${deal.property.address}

    If you have any questions or would like to discuss, please don't hesitate to reach out.

    We're ready to move forward quickly.
      \`;
    }
    ```
  </action>
  <verify>
    1. `npm run build` passes TypeScript checks
    2. Verify executeSequenceStep returns proper result object with success/error/nextStepQueued
    3. Verify EMAIL steps call sendOfferEmail and log to FollowUpEvent
    4. Verify WAIT steps don't send but log completion
    5. Verify SMS steps are marked as skipped (deferred to Phase 2.1)
    6. Check that FollowUpEvent records are created with immutable sentAt timestamp
    7. Verify next step is enqueued with proper delay if applicable
    8. Verify sequence marked COMPLETED when final step executed successfully
  </verify>
  <done>
    - executeSequenceStep() processes each step type (EMAIL, SMS deferred, WAIT)
    - Paused/completed sequences skip execution and return skipped status
    - FollowUpEvent immutable log records created for each step (sentAt timestamp, status)
    - Next step enqueued with proper delay calculation
    - Sequence marked COMPLETED when last step finishes
    - Failed steps throw error for BullMQ retry logic
    - Default follow-up email content with property context
  </done>
</task>

<task type="auto">
  <name>Task 3: Sequence template CRUD and pause/resume API</name>
  <files>
    src/app/api/sequences/route.ts
    src/app/api/sequences/[id]/route.ts
  </files>
  <action>
    **1. Create `src/app/api/sequences/route.ts`:**
    CRUD endpoints for sequence templates.

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { auth } from '@clerk/nextjs/server';
    import { prisma } from '@/lib/db';
    import { z } from 'zod';

    const createSequenceSchema = z.object({
      name: z.string().min(1).max(100),
      description: z.string().optional(),
      steps: z.array(
        z.object({
          type: z.enum(['EMAIL', 'SMS', 'WAIT']),
          delayDays: z.number().optional(),
          subject: z.string().optional(),
          htmlContent: z.string().optional(),
          plainText: z.string().optional(),
          phoneNumber: z.string().optional(),
        })
      ).min(1),
    });

    export async function GET(req: NextRequest) {
      const { userId } = await auth();

      if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const sequences = await prisma.followUpSequence.findMany({
          where: { userId },
          select: {
            id: true,
            name: true,
            description: true,
            enabled: true,
            createdAt: true,
            steps: true,
          },
          orderBy: { createdAt: 'desc' },
        });

        return NextResponse.json({ sequences });
      } catch (error) {
        console.error('Fetch sequences error:', error);
        return NextResponse.json(
          { error: 'Failed to fetch sequences' },
          { status: 500 }
        );
      }
    }

    export async function POST(req: NextRequest) {
      const { userId } = await auth();

      if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const body = await req.json();
        const parsed = createSequenceSchema.parse(body);

        const sequence = await prisma.followUpSequence.create({
          data: {
            userId,
            name: parsed.name,
            description: parsed.description,
            steps: parsed.steps,
            enabled: true,
          },
        });

        return NextResponse.json({ sequence }, { status: 201 });
      } catch (error: any) {
        if (error instanceof z.ZodError) {
          return NextResponse.json(
            { error: 'Invalid input', details: error.errors },
            { status: 400 }
          );
        }
        console.error('Create sequence error:', error);
        return NextResponse.json(
          { error: 'Failed to create sequence' },
          { status: 500 }
        );
      }
    }
    ```

    **2. Create `src/app/api/sequences/[id]/route.ts`:**
    Get, update, and pause/resume endpoints.

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { auth } from '@clerk/nextjs/server';
    import { prisma } from '@/lib/db';

    export async function GET(
      req: NextRequest,
      { params }: { params: { id: string } }
    ) {
      const { userId } = await auth();

      if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const sequence = await prisma.followUpSequence.findUnique({
          where: { id: params.id },
          include: {
            scheduledSequences: {
              where: { status: 'ACTIVE' },
              select: {
                id: true,
                dealId: true,
                nextStepAt: true,
                currentStep: true,
              },
            },
          },
        });

        if (!sequence || sequence.userId !== userId) {
          return NextResponse.json(
            { error: 'Sequence not found' },
            { status: 404 }
          );
        }

        return NextResponse.json({ sequence });
      } catch (error) {
        console.error('Fetch sequence error:', error);
        return NextResponse.json(
          { error: 'Failed to fetch sequence' },
          { status: 500 }
        );
      }
    }

    export async function PATCH(
      req: NextRequest,
      { params }: { params: { id: string } }
    ) {
      const { userId } = await auth();

      if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const body = await req.json();
        const { action, scheduledId } = body;

        // Verify ownership
        const sequence = await prisma.followUpSequence.findUnique({
          where: { id: params.id },
        });

        if (!sequence || sequence.userId !== userId) {
          return NextResponse.json(
            { error: 'Sequence not found' },
            { status: 404 }
          );
        }

        if (action === 'pause' && scheduledId) {
          // Pause specific scheduled instance
          const updated = await prisma.followUpScheduled.update({
            where: { id: scheduledId },
            data: { status: 'PAUSED' },
          });

          return NextResponse.json({
            success: true,
            scheduled: updated,
          });
        } else if (action === 'resume' && scheduledId) {
          // Resume specific scheduled instance
          const updated = await prisma.followUpScheduled.update({
            where: { id: scheduledId },
            data: { status: 'ACTIVE' },
          });

          return NextResponse.json({
            success: true,
            scheduled: updated,
          });
        } else {
          return NextResponse.json(
            { error: 'Invalid action or missing scheduledId' },
            { status: 400 }
          );
        }
      } catch (error) {
        console.error('Update sequence error:', error);
        return NextResponse.json(
          { error: 'Failed to update sequence' },
          { status: 500 }
        );
      }
    }
    ```
  </action>
  <verify>
    1. GET /api/sequences returns array of user's sequences (ordered by createdAt desc)
    2. POST /api/sequences with valid payload creates sequence and returns 201
    3. POST /api/sequences with invalid steps array returns 400 with validation errors
    4. GET /api/sequences/[id] returns sequence with active scheduled instances
    5. GET /api/sequences/[id] with invalid ID returns 404
    6. PATCH /api/sequences/[id] with action=pause updates scheduled status to PAUSED
    7. PATCH /api/sequences/[id] with action=resume updates scheduled status to ACTIVE
    8. Verify endpoints properly authorize (userId check)
  </verify>
  <done>
    - GET /api/sequences returns user's sequence templates with step details
    - POST /api/sequences creates new template with validated step array
    - GET /api/sequences/[id] returns template details and active scheduled instances
    - PATCH /api/sequences/[id] pause/resume controls per scheduled deal instance
    - All endpoints verify userId ownership before returning/modifying data
    - Step validation schema enforces required fields (type, optional delayDays/content)
  </done>
</task>

</tasks>

<verification>
1. BullMQ queue configured and worker registered with Redis
2. Job retry logic with exponential backoff (5 attempts, starting 2s)
3. Sequence executor processes EMAIL, SMS (deferred), WAIT steps correctly
4. FollowUpEvent immutable log creates records with sentAt timestamp
5. Next step enqueued with delay calculation for WAIT steps
6. Sequence marked COMPLETED when all steps finish
7. Sequence template CRUD API functional
8. Pause/resume endpoints update FollowUpScheduled status
9. Build passes TypeScript checks
</verification>

<success_criteria>
- BullMQ queue setup with Redis connection (reuses Phase 1 Redis)
- Job handler processes follow-up steps with retry logic (5 attempts, exponential backoff)
- Sequence executor handles EMAIL/SMS/WAIT step types with immutable event logging
- FollowUpScheduled progresses through steps (currentStep increments, nextStepAt calculated)
- Sequence marked COMPLETED when all steps executed successfully
- Failed steps trigger job retry (up to 5 times)
- Pause/resume pauses execution without deleting event history
- GET /api/sequences returns user templates, POST creates new template
- PATCH /api/sequences/[id] pause/resume per scheduled instance
</success_criteria>

<output>
After completion, create `.planning/phases/02-intelligent-offer-automation/02-02-SUMMARY.md`
</output>
