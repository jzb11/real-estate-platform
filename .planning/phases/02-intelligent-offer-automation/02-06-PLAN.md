---
phase: 02-intelligent-offer-automation
plan: "06"
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - src/lib/monitoring/sendgridMonitor.ts
  - src/app/api/monitoring/status/route.ts
  - src/app/api/monitoring/alerts/route.ts
autonomous: true
requirements:
  - AU-05
  - AU-06

must_haves:
  truths:
    - "System monitors email bounce rate and alerts user if > 5%"
    - "System monitors complaint rate and alerts user if > 0.1%"
    - "System polls SendGrid sender score daily and alerts if < 80"
    - "Dashboard shows email deliverability metrics (bounce %, complaint %, sender score)"
    - "Alerts are created as records in database (viewable via API)"
    - "User can view historical deliverability trends"
  artifacts:
    - path: "src/lib/monitoring/sendgridMonitor.ts"
      provides: "SendGrid reputation monitoring and alert generation"
      exports: ["checkDeliverabilityMetrics", "generateAlert"]
    - path: "src/app/api/monitoring/status/route.ts"
      provides: "GET /api/monitoring/status returns current metrics"
      exports: ["GET"]
    - path: "src/app/api/monitoring/alerts/route.ts"
      provides: "GET /api/monitoring/alerts returns alert history"
      exports: ["GET"]
  key_links:
    - from: "src/lib/monitoring/sendgridMonitor.ts"
      to: "prisma.sendgridWebhook"
      via: "Aggregates webhook events to calculate bounce/complaint rates"
      pattern: "prisma\\.sendgridWebhook\\.count"
    - from: "src/lib/monitoring/sendgridMonitor.ts"
      to: "SendGrid Reputation API"
      via: "Polls sender score from SendGrid Dashboard API"
      pattern: "fetch.*sendgrid.*reputation"

---

<objective>
Monitor email deliverability via SendGrid webhooks and reputation API. Alerts when metrics exceed thresholds (bounce >5%, complaint >0.1%, sender score <80).

Purpose: Prevents reputation damage and costly email issues. Real-time visibility into delivery health.

Output: Deliverability monitoring API, alert history, metrics dashboard support.
</objective>

<execution_context>
@/Users/jakezebe/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakezebe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-intelligent-offer-automation/02-CONTEXT.md
@.planning/phases/02-intelligent-offer-automation/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: SendGrid monitoring and alert generation</name>
  <files>
    src/lib/monitoring/sendgridMonitor.ts
  </files>
  <action>
    Create `src/lib/monitoring/sendgridMonitor.ts`. This monitors SendGrid metrics and generates alerts.

    ```typescript
    import { prisma } from '@/lib/db';

    const SENDGRID_API_KEY = process.env.SENDGRID_API_KEY;

    export interface DeliverabilityMetrics {
      totalSent: number;
      bounced: number;
      bounceRate: number;
      complained: number;
      complaintRate: number;
      senderScore: number;
      opened: number;
      openRate: number;
    }

    /**
     * Aggregate webhook events to calculate bounce/complaint rates
     * Covers last 30 days
     */
    export async function calculateDeliverabilityMetrics(
      userId?: string
    ): Promise<DeliverabilityMetrics> {
      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);

      // Get webhook stats
      const delivered = await prisma.sendgridWebhook.count({
        where: {
          eventType: 'DELIVERED',
          timestamp: { gte: thirtyDaysAgo },
        },
      });

      const bounced = await prisma.sendgridWebhook.count({
        where: {
          eventType: 'BOUNCE',
          timestamp: { gte: thirtyDaysAgo },
        },
      });

      const complained = await prisma.sendgridWebhook.count({
        where: {
          eventType: 'COMPLAINT',
          timestamp: { gte: thirtyDaysAgo },
        },
      });

      const opened = await prisma.sendgridWebhook.count({
        where: {
          eventType: 'OPEN',
          timestamp: { gte: thirtyDaysAgo },
        },
      });

      const totalSent = delivered + bounced;

      return {
        totalSent,
        bounced,
        bounceRate: totalSent > 0 ? (bounced / totalSent) * 100 : 0,
        complained,
        complaintRate: totalSent > 0 ? (complained / totalSent) * 100 : 0,
        senderScore: await fetchSenderScore(),
        opened,
        openRate: totalSent > 0 ? (opened / totalSent) * 100 : 0,
      };
    }

    /**
     * Fetch sender reputation score from SendGrid Stats API
     * Score 0-100, >85 is excellent
     */
    async function fetchSenderScore(): Promise<number> {
      if (!SENDGRID_API_KEY) {
        console.warn('SENDGRID_API_KEY not set');
        return 0;
      }

      try {
        const response = await fetch(
          'https://api.sendgrid.com/v3/user/account',
          {
            headers: {
              Authorization: \`Bearer \${SENDGRID_API_KEY}\`,
            },
          }
        );

        if (!response.ok) {
          console.error(
            'Failed to fetch sender score:',
            response.status
          );
          return 0;
        }

        const data = await response.json();

        // SendGrid API returns reputation.reputation_score or similar
        // Fallback to 85 (good) if not available
        return data.reputation?.reputation_score ?? 85;
      } catch (error) {
        console.error('Error fetching sender score:', error);
        return 0;
      }
    }

    /**
     * Check metrics and generate alerts if thresholds exceeded
     */
    export async function checkDeliverabilityMetrics(
      userId: string
    ): Promise<string[]> {
      try {
        const metrics = await calculateDeliverabilityMetrics();
        const alerts: string[] = [];

        // Check bounce rate threshold (>5%)
        if (metrics.bounceRate > 5) {
          alerts.push('BOUNCE_RATE_HIGH');
          await generateAlert(
            userId,
            'BOUNCE_RATE_HIGH',
            \`Bounce rate is \${metrics.bounceRate.toFixed(2)}% (threshold: 5%)\`,
            metrics
          );
        }

        // Check complaint rate threshold (>0.1%)
        if (metrics.complaintRate > 0.1) {
          alerts.push('COMPLAINT_RATE_HIGH');
          await generateAlert(
            userId,
            'COMPLAINT_RATE_HIGH',
            \`Complaint rate is \${metrics.complaintRate.toFixed(3)}% (threshold: 0.1%)\`,
            metrics
          );
        }

        // Check sender score threshold (<80)
        if (metrics.senderScore < 80 && metrics.senderScore > 0) {
          alerts.push('SENDER_SCORE_LOW');
          await generateAlert(
            userId,
            'SENDER_SCORE_LOW',
            \`Sender score is \${metrics.senderScore} (threshold: 80)\`,
            metrics
          );
        }

        return alerts;
      } catch (error) {
        console.error('Error checking deliverability metrics:', error);
        return [];
      }
    }

    /**
     * Create alert record in database
     */
    export async function generateAlert(
      userId: string,
      alertType: string,
      message: string,
      metrics: DeliverabilityMetrics
    ) {
      try {
        // Check if alert already exists for today
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        const existingAlert = await prisma.deliverabilityAlert.findFirst({
          where: {
            userId,
            alertType,
            createdAt: { gte: today },
          },
        });

        if (existingAlert) {
          // Don't spam â€” one alert per type per day
          return;
        }

        await prisma.deliverabilityAlert.create({
          data: {
            userId,
            alertType,
            message,
            metrics: metrics as any,
            acknowledged: false,
          },
        });

        console.log(\`Alert created: \${alertType} for user \${userId}\`);
      } catch (error) {
        console.error('Error creating alert:', error);
      }
    }

    /**
     * Cron job to check metrics periodically (call from API or scheduled task)
     * Should be called daily
     */
    export async function dailyMonitoringCheck(userId: string) {
      return checkDeliverabilityMetrics(userId);
    }
    ```

    **Add to `prisma/schema.prisma`:**
    ```prisma
    model DeliverabilityAlert {
      id            String    @id @default(uuid())
      userId        String
      alertType     String    // BOUNCE_RATE_HIGH, COMPLAINT_RATE_HIGH, SENDER_SCORE_LOW
      message       String
      metrics       Json      // Snapshot of metrics at alert time
      acknowledged  Boolean   @default(false)
      createdAt     DateTime  @default(now())
      updatedAt     DateTime  @updatedAt

      user User @relation(fields: [userId], references: [id], onDelete: Cascade)

      @@index([userId, alertType, createdAt])
    }
    ```

    Then run migration:
    ```bash
    npx prisma migrate dev --name add_deliverability_alerts
    ```
  </action>
  <verify>
    1. calculateDeliverabilityMetrics() aggregates webhook events from last 30 days
    2. fetchSenderScore() calls SendGrid API and returns numeric score
    3. checkDeliverabilityMetrics() generates alerts if thresholds exceeded
    4. generateAlert() creates immutable DeliverabilityAlert record
    5. One alert per type per day (prevents spam)
    6. Metrics include bounce rate, complaint rate, sender score, open rate
    7. Build passes TypeScript checks
  </verify>
  <done>
    - DeliverabilityMetrics aggregation from webhook events
    - Sender score fetched from SendGrid Stats API
    - Alert generation for bounce rate >5%, complaint rate >0.1%, sender score <80
    - DeliverabilityAlert table stores immutable alert history
    - dailyMonitoringCheck() can be called from scheduled task
    - Metrics snapshot stored with each alert for audit trail
  </done>
</task>

<task type="auto">
  <name>Task 2: Monitoring status and alerts API</name>
  <files>
    src/app/api/monitoring/status/route.ts
    src/app/api/monitoring/alerts/route.ts
  </files>
  <action>
    **1. Create `src/app/api/monitoring/status/route.ts`:**
    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { auth } from '@clerk/nextjs/server';
    import { calculateDeliverabilityMetrics, checkDeliverabilityMetrics } from '@/lib/monitoring/sendgridMonitor';

    export async function GET(req: NextRequest) {
      const { userId } = await auth();

      if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const metrics = await calculateDeliverabilityMetrics();

        // Trigger alert check
        const alerts = await checkDeliverabilityMetrics(userId);

        return NextResponse.json({
          metrics,
          activeAlerts: alerts,
          healthStatus:
            metrics.bounceRate <= 5 &&
            metrics.complaintRate <= 0.1 &&
            metrics.senderScore >= 80
              ? 'HEALTHY'
              : 'WARNING',
        });
      } catch (error) {
        console.error('Monitoring status error:', error);
        return NextResponse.json(
          { error: 'Failed to fetch metrics' },
          { status: 500 }
        );
      }
    }
    ```

    **2. Create `src/app/api/monitoring/alerts/route.ts`:**
    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { auth } from '@clerk/nextjs/server';
    import { prisma } from '@/lib/db';

    export async function GET(req: NextRequest) {
      const { userId } = await auth();

      if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const limit = parseInt(req.nextUrl.searchParams.get('limit') || '30');
        const unreadOnly =
          req.nextUrl.searchParams.get('unreadOnly') === 'true';

        const alerts = await prisma.deliverabilityAlert.findMany({
          where: {
            userId,
            ...(unreadOnly && { acknowledged: false }),
          },
          select: {
            id: true,
            alertType: true,
            message: true,
            metrics: true,
            acknowledged: true,
            createdAt: true,
          },
          orderBy: { createdAt: 'desc' },
          take: limit,
        });

        return NextResponse.json({ alerts });
      } catch (error) {
        console.error('Fetch alerts error:', error);
        return NextResponse.json(
          { error: 'Failed to fetch alerts' },
          { status: 500 }
        );
      }
    }

    export async function PATCH(req: NextRequest) {
      const { userId } = await auth();

      if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const { alertId, acknowledged } = await req.json();

        const alert = await prisma.deliverabilityAlert.findUnique({
          where: { id: alertId },
        });

        if (!alert || alert.userId !== userId) {
          return NextResponse.json(
            { error: 'Alert not found' },
            { status: 404 }
          );
        }

        const updated = await prisma.deliverabilityAlert.update({
          where: { id: alertId },
          data: { acknowledged },
        });

        return NextResponse.json({ alert: updated });
      } catch (error) {
        console.error('Update alert error:', error);
        return NextResponse.json(
          { error: 'Failed to update alert' },
          { status: 500 }
        );
      }
    }
    ```
  </action>
  <verify>
    1. GET /api/monitoring/status returns metrics and activeAlerts
    2. healthStatus is HEALTHY or WARNING based on thresholds
    3. GET /api/monitoring/alerts returns alert history (limit 30 default)
    4. unreadOnly=true returns only unacknowledged alerts
    5. PATCH /api/monitoring/alerts/[id] marks alert as acknowledged
    6. Both endpoints verify userId authorization
    7. Build passes TypeScript checks
  </verify>
  <done>
    - GET /api/monitoring/status returns current deliverability metrics
    - GET /api/monitoring/alerts returns alert history with filtering
    - PATCH acknowledges alerts (marks as read)
    - healthStatus indicates HEALTHY or WARNING based on metric thresholds
    - All endpoints properly authorized and error-handled
  </done>
</task>

</tasks>

<verification>
1. DeliverabilityMetrics aggregation from webhook events working
2. SendGrid sender score fetched and included in metrics
3. Alerts generated for bounce >5%, complaint >0.1%, score <80
4. DeliverabilityAlert table stores immutable history
5. One alert per type per day (prevents spam)
6. Status API returns metrics and active alerts
7. Alerts API returns history with unreadOnly filtering
8. Build passes TypeScript checks
</verification>

<success_criteria>
- calculateDeliverabilityMetrics() aggregates webhook events from 30 days
- Bounce rate, complaint rate, sender score monitored and alerting
- DeliverabilityAlert records created and immutable
- GET /api/monitoring/status returns current metrics + health status
- GET /api/monitoring/alerts returns alert history + filtering
- PATCH acknowledges alerts
- No duplicate alerts per type per day
- All endpoints properly authorized
</success_criteria>

<output>
After completion, create `.planning/phases/02-intelligent-offer-automation/02-06-SUMMARY.md`
</output>
