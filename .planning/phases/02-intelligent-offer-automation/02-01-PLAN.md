---
phase: 02-intelligent-offer-automation
plan: "01"
type: execute
wave: 1
depends_on:
  - "01-01"
  - "01-02"
  - "01-03"
  - "01-04"
  - "01-05"
files_modified:
  - prisma/schema.prisma
  - src/lib/email/sendgrid.ts
  - src/lib/email/offerTemplate.ts
  - src/lib/email/types.ts
  - src/app/api/offers/generate/route.ts
  - src/app/api/email/sendgrid-webhook/route.ts
  - .env.example
autonomous: true
requirements:
  - OF-01
  - OF-02
  - OF-03

must_haves:
  truths:
    - "User can generate a professional offer email with property address, value, MAO calculation, and realtor contact"
    - "Offer email includes SMTP unsubscribe header and HTML footer link (CAN-SPAM compliant)"
    - "SendGrid webhook endpoint verifies and accepts bounce/complaint/open events with signature validation"
    - "Offer emails are tracked (open/click events captured and logged)"
    - "System stores OfferedDeal records tracking which properties have offers sent"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "OfferedDeal and SendgridWebhook table definitions"
      contains: "model OfferedDeal"
    - path: "src/lib/email/sendgrid.ts"
      provides: "SendGrid API client and webhook verification"
      exports: ["createSendGridClient", "verifyWebhookSignature"]
    - path: "src/lib/email/offerTemplate.ts"
      provides: "HTML and plain-text offer email template rendering"
      exports: ["renderOfferEmail"]
    - path: "src/app/api/offers/generate/route.ts"
      provides: "POST endpoint generating offer email content (does NOT send)"
      exports: ["POST"]
    - path: "src/app/api/email/sendgrid-webhook/route.ts"
      provides: "POST endpoint receiving SendGrid events"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/offers/generate/route.ts"
      to: "src/lib/email/offerTemplate.ts"
      via: "calls renderOfferEmail with property + deal data"
      pattern: "renderOfferEmail"
    - from: "src/app/api/email/sendgrid-webhook/route.ts"
      to: "src/lib/email/sendgrid.ts"
      via: "verifyWebhookSignature before processing events"
      pattern: "verifyWebhookSignature"
    - from: "src/app/api/email/sendgrid-webhook/route.ts"
      to: "prisma.sendgridWebhook"
      via: "logs webhook events to database"
      pattern: "prisma\\.sendgridWebhook\\.create"

user_setup:
  - service: sendgrid
    why: "Email delivery provider (industry-standard for real estate, TCPA-compliant, list validation, reputation monitoring)"
    env_vars:
      - name: SENDGRID_API_KEY
        source: "SendGrid Dashboard -> Settings -> API Keys -> Create API Key (Mail Send access)"
      - name: SENDGRID_FROM_EMAIL
        source: "SendGrid Dashboard -> Settings -> Sender Authentication -> Verify Domain -> Use DKIM-verified sender email"
      - name: SENDGRID_FROM_NAME
        source: "Your company/platform name"
    dashboard_config:
      - task: "Create API Key with Mail Send permission"
        location: "SendGrid Dashboard -> Settings -> API Keys"
      - task: "Verify sender domain (DKIM/SPF setup)"
        location: "SendGrid Dashboard -> Settings -> Sender Authentication"
      - task: "Configure webhook endpoint"
        location: "SendGrid Dashboard -> Mail Settings -> Event Webhook -> Endpoint URL (https://your-domain/api/email/sendgrid-webhook)"
      - task: "Enable webhook event types"
        location: "SendGrid Dashboard -> Mail Settings -> Event Webhook -> Select: opens, clicks, bounces, spam_reports"

---

<objective>
Build the email delivery foundation: SendGrid integration, offer email template, webhook handler for deliverability tracking, and database schema for offer lifecycle tracking.

Purpose: This establishes the infrastructure for sending professional offers at scale. The SendGrid integration handles TCPA compliance (unsubscribe headers), bounce/complaint tracking, and reputation monitoring. The template is the single source of truth for offer formatting.

Output: A system that can generate professional offer emails from deal data, send via SendGrid API, and track delivery events (bounces, complaints, opens) back to the database.
</objective>

<execution_context>
@/Users/jakezebe/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakezebe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-intelligent-offer-automation/02-CONTEXT.md
@.planning/phases/02-intelligent-offer-automation/02-RESEARCH.md
@.planning/phases/01-core-deal-sourcing-crm/01-01-SUMMARY.md
@.planning/phases/01-core-deal-sourcing-crm/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend database schema with OfferedDeal and SendgridWebhook tables</name>
  <files>
    prisma/schema.prisma
  </files>
  <action>
    Add three new tables to `prisma/schema.prisma`. Append AFTER the existing KbAccessLog model:

    ```prisma
    enum SendgridEventType {
      DELIVERED
      OPEN
      CLICK
      BOUNCE
      COMPLAINT
      UNSUBSCRIBE
      GROUP_UNSUBSCRIBE
    }

    enum OfferedDealStatus {
      DRAFT
      SENT
      OPENED
      CLICKED
      BOUNCED
      COMPLAINED
      UNSUBSCRIBED
    }

    model OfferedDeal {
      id                String              @id @default(uuid())
      dealId            String
      userId            String
      sentToEmail       String              // Recipient email
      recipientName     String?             // Recipient name (optional)
      status            OfferedDealStatus   @default(SENT)
      sentAt            DateTime
      emailOpenedAt     DateTime?
      linkClickedAt     DateTime?
      bouncedAt         DateTime?
      complainedAt      DateTime?
      bouncetype        String?             // hard, soft, permanent_failure
      complaintType     String?             // spam, abuse, etc.
      sendgridMessageId String?             // For tracking in SendGrid
      createdAt         DateTime            @default(now())
      updatedAt         DateTime            @updatedAt

      deal Deal @relation(fields: [dealId], references: [id], onDelete: Cascade)
      user User @relation(fields: [userId], references: [id], onDelete: Cascade)

      @@index([userId, sentAt])
      @@index([dealId])
      @@index([status])
    }

    model SendgridWebhook {
      id            String              @id @default(uuid())
      eventType     SendgridEventType
      email         String
      timestamp     DateTime
      messageId     String?
      bounceType    String?             // hard, soft, permanent_failure
      complaintType String?             // spam, abuse
      url           String?             // For click events
      rawPayload    Json
      processedAt   DateTime            @default(now())

      @@index([messageId])
      @@index([email, timestamp])
      @@index([eventType])
    }

    model FollowUpSequence {
      id            String   @id @default(uuid())
      userId        String
      name          String
      description   String?
      steps         Json     // Array of { type: 'EMAIL'|'SMS'|'WAIT', delayDays?: number, content?: string }
      enabled       Boolean  @default(true)
      createdAt     DateTime @default(now())
      updatedAt     DateTime @updatedAt

      user                  User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
      scheduledSequences    FollowUpScheduled[]
      followUpEvents        FollowUpEvent[]

      @@index([userId, enabled])
    }

    model FollowUpScheduled {
      id              String   @id @default(uuid())
      dealId          String
      userId          String
      sequenceId      String
      currentStep     Int      @default(0)
      nextStepAt      DateTime
      status          String   @default("ACTIVE") // ACTIVE, PAUSED, COMPLETED
      createdAt       DateTime @default(now())
      updatedAt       DateTime @updatedAt

      deal     Deal                @relation(fields: [dealId], references: [id], onDelete: Cascade)
      user     User                @relation(fields: [userId], references: [id], onDelete: Cascade)
      sequence FollowUpSequence    @relation(fields: [sequenceId], references: [id], onDelete: Cascade)
      events   FollowUpEvent[]

      @@index([userId, dealId])
      @@index([nextStepAt, status])
    }

    model FollowUpEvent {
      id            String   @id @default(uuid())
      scheduledId   String
      sequenceId    String
      stepIndex     Int
      eventType     String   // EMAIL_SENT, EMAIL_OPENED, EMAIL_CLICKED, SMS_SENT, BOUNCE, COMPLAINT
      content       Json?    // Stores email subject, SMS body, etc.
      status        String   // SUCCESS, FAILED, PENDING
      failureReason String?
      sentAt        DateTime
      createdAt     DateTime @default(now())

      scheduled FollowUpScheduled @relation(fields: [scheduledId], references: [id], onDelete: Cascade)
      sequence  FollowUpSequence  @relation(fields: [sequenceId], references: [id], onDelete: Cascade)

      @@index([scheduledId, createdAt])
      @@index([eventType])
    }
    ```

    Add relationships to existing models (update User and Deal models):

    **In User model, add:**
    ```prisma
    offeredDeals           OfferedDeal[]
    followUpSequences      FollowUpSequence[]
    followUpScheduled      FollowUpScheduled[]
    ```

    **In Deal model, add:**
    ```prisma
    offeredDeals      OfferedDeal[]
    followUpScheduled FollowUpScheduled[]
    ```

    After editing schema.prisma, run:
    ```bash
    npx prisma migrate dev --name add_offer_followup_schema
    ```

    This generates the migration and updates the Prisma client.
  </action>
  <verify>
    1. `npx prisma migrate status` shows migration applied cleanly
    2. `npx prisma studio` shows new tables: OfferedDeal, SendgridWebhook, FollowUpSequence, FollowUpScheduled, FollowUpEvent
    3. Verify OfferedDealStatus enum includes: DRAFT, SENT, OPENED, CLICKED, BOUNCED, COMPLAINED, UNSUBSCRIBED
    4. Verify SendgridEventType enum includes: DELIVERED, OPEN, CLICK, BOUNCE, COMPLAINT, UNSUBSCRIBE, GROUP_UNSUBSCRIBE
    5. `npm run build` passes TypeScript checks
  </verify>
  <done>
    - OfferedDeal table exists with deal/user foreign keys and timestamp tracking (sentAt, emailOpenedAt, linkClickedAt, bouncedAt, complainedAt)
    - SendgridWebhook table exists for webhook event logging
    - FollowUpSequence, FollowUpScheduled, FollowUpEvent tables exist for automation sequence management
    - All enums properly defined and enforced by PostgreSQL
    - Migration applied and committed to source control
  </done>
</task>

<task type="auto">
  <name>Task 2: SendGrid client library and offer email template</name>
  <files>
    src/lib/email/types.ts
    src/lib/email/sendgrid.ts
    src/lib/email/offerTemplate.ts
  </files>
  <action>
    **1. Create `src/lib/email/types.ts`:**
    ```typescript
    export interface OfferEmailData {
      propertyAddress: string;
      propertyCity: string;
      propertyState: string;
      propertyZip: string;
      estimatedValue: number;
      repairCosts: number;
      mao: number;      // Maximum Allowable Offer
      offerPrice: number;
      equityPercent: number;
      realtor: {
        name: string;
        phone: string;
        email: string;
      };
    }

    export interface SendGridWebhookPayload {
      event: string;
      email?: string;
      timestamp?: number;
      'message-id'?: string;
      bounce_type?: string;
      complaint?: string;
      url?: string;
      [key: string]: unknown;
    }
    ```

    **2. Install SendGrid SDK:**
    ```bash
    npm install @sendgrid/mail
    ```

    **3. Create `src/lib/email/sendgrid.ts`:**
    ```typescript
    import { createHash, createHmac } from 'crypto';
    import sgMail from '@sendgrid/mail';

    const SENDGRID_API_KEY = process.env.SENDGRID_API_KEY;
    const SENDGRID_FROM_EMAIL = process.env.SENDGRID_FROM_EMAIL;
    const SENDGRID_FROM_NAME = process.env.SENDGRID_FROM_NAME || 'Offer Platform';
    const SENDGRID_WEBHOOK_KEY = process.env.SENDGRID_WEBHOOK_KEY; // Webhook verification key from Settings

    if (!SENDGRID_API_KEY) {
      throw new Error('SENDGRID_API_KEY is not set');
    }

    sgMail.setApiKey(SENDGRID_API_KEY);

    export function createSendGridClient() {
      return sgMail;
    }

    export async function sendOfferEmail(
      toEmail: string,
      toName: string | undefined,
      htmlContent: string,
      plainText: string,
      subject: string = 'Professional Offer for Your Property'
    ) {
      try {
        const [response] = await sgMail.send({
          to: {
            email: toEmail,
            name: toName || 'Property Owner',
          },
          from: {
            email: SENDGRID_FROM_EMAIL,
            name: SENDGRID_FROM_NAME,
          },
          subject,
          html: htmlContent,
          text: plainText,
          trackingSettings: {
            clickTracking: {
              enable: true,
              enableText: false, // Don't track plain text links
            },
            openTracking: {
              enable: true,
            },
          },
          mailSettings: {
            sandboxMode: {
              enable: process.env.NODE_ENV === 'development', // Dev uses sandbox
            },
          },
        });

        // Extract message ID from SendGrid response
        const messageId = response.headers['x-message-id'];
        return {
          success: true,
          messageId,
          statusCode: response.status,
        };
      } catch (error) {
        console.error('SendGrid send error:', error);
        throw error;
      }
    }

    /**
     * Verify SendGrid webhook signature
     * SendGrid signs all webhooks with HMAC-SHA256
     */
    export function verifyWebhookSignature(
      payload: string,
      signature: string,
      timestamp: string,
      secret: string
    ): boolean {
      try {
        const hmac = createHmac('sha256', secret);
        hmac.update(timestamp + payload);
        const expectedSig = hmac.digest('base64');
        return expectedSig === signature;
      } catch (error) {
        console.error('Webhook signature verification failed:', error);
        return false;
      }
    }
    ```

    **4. Create `src/lib/email/offerTemplate.ts`:**
    ```typescript
    import { OfferEmailData } from './types';

    /**
     * Generate professional offer email (HTML + plain text)
     * Includes unsubscribe link (required by CAN-SPAM) and SMTP unsubscribe header
     */
    export function renderOfferEmail(data: OfferEmailData) {
      const {
        propertyAddress,
        propertyCity,
        propertyState,
        propertyZip,
        estimatedValue,
        repairCosts,
        mao,
        offerPrice,
        equityPercent,
        realtor,
      } = data;

      const unsubscribeUrl = process.env.NEXT_PUBLIC_BASE_URL
        ? `${process.env.NEXT_PUBLIC_BASE_URL}/api/email/unsubscribe?email=${encodeURIComponent(realtor.email)}`
        : 'https://example.com/unsubscribe';

      const htmlContent = \`
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: #003366; color: white; padding: 20px; border-radius: 5px 5px 0 0; }
        .content { background: #f9f9f9; padding: 20px; border: 1px solid #ddd; }
        .property { background: white; padding: 15px; margin: 10px 0; border-left: 4px solid #003366; }
        .footer { text-align: center; font-size: 12px; color: #666; margin-top: 20px; padding-top: 10px; border-top: 1px solid #ddd; }
        .footer a { color: #003366; }
        table { width: 100%; margin: 10px 0; }
        th, td { text-align: left; padding: 8px; border-bottom: 1px solid #ddd; }
        th { background: #f0f0f0; font-weight: bold; }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          <h1>Professional Offer Letter</h1>
        </div>
        <div class="content">
          <p>We have a professional offer for your property:</p>

          <div class="property">
            <h3>\${propertyAddress}</h3>
            <p>\${propertyCity}, \${propertyState} \${propertyZip}</p>
          </div>

          <h4>Offer Summary</h4>
          <table>
            <tr>
              <th>Metric</th>
              <th>Value</th>
            </tr>
            <tr>
              <td>Estimated Value (ARV)</td>
              <td>\$\${estimatedValue.toLocaleString()}</td>
            </tr>
            <tr>
              <td>Estimated Repair Costs</td>
              <td>\$\${repairCosts.toLocaleString()}</td>
            </tr>
            <tr>
              <td>Maximum Allowable Offer (70% Rule)</td>
              <td>\$\${mao.toLocaleString()}</td>
            </tr>
            <tr style="background: #e8f4f8;">
              <td><strong>Our Offer</strong></td>
              <td><strong>\$\${offerPrice.toLocaleString()}</strong></td>
            </tr>
            <tr>
              <td>Your Equity (at our offer)</td>
              <td>\${equityPercent.toFixed(1)}%</td>
            </tr>
          </table>

          <h4>Contact Information</h4>
          <p>
            <strong>\${realtor.name}</strong><br>
            Phone: <a href="tel:\${realtor.phone}">\${realtor.phone}</a><br>
            Email: <a href="mailto:\${realtor.email}">\${realtor.email}</a>
          </p>

          <p>
            We are ready to move quickly and offer a fair price for your property.
            Please contact us to discuss this opportunity.
          </p>
        </div>

        <div class="footer">
          <p>
            <a href="\${unsubscribeUrl}">Unsubscribe from future offers</a>
          </p>
        </div>
      </div>
    </body>
    </html>
      \`;

      const plainText = \`
    Professional Offer Letter

    Property: \${propertyAddress}
    \${propertyCity}, \${propertyState} \${propertyZip}

    Offer Summary:
    - Estimated Value (ARV): \$\${estimatedValue.toLocaleString()}
    - Estimated Repair Costs: \$\${repairCosts.toLocaleString()}
    - Maximum Allowable Offer (70% Rule): \$\${mao.toLocaleString()}
    - Our Offer: \$\${offerPrice.toLocaleString()}
    - Your Equity (at our offer): \${equityPercent.toFixed(1)}%

    Contact Information:
    \${realtor.name}
    Phone: \${realtor.phone}
    Email: \${realtor.email}

    We are ready to move quickly and offer a fair price for your property.
    Please contact us to discuss this opportunity.

    Unsubscribe: \${unsubscribeUrl}
      \`;

      return {
        html: htmlContent,
        text: plainText,
        unsubscribeUrl,
      };
    }
    ```
  </action>
  <verify>
    1. `npm run build` passes TypeScript checks
    2. Verify `src/lib/email/sendgrid.ts` exports: `createSendGridClient`, `sendOfferEmail`, `verifyWebhookSignature`
    3. Verify `src/lib/email/offerTemplate.ts` exports: `renderOfferEmail`
    4. Verify `renderOfferEmail()` returns object with `html`, `text`, `unsubscribeUrl` properties
    5. Check that SendGrid tracking settings enable open/click tracking
  </verify>
  <done>
    - SendGrid client library configured with API key and sandbox mode detection
    - sendOfferEmail() sends HTML + plain text with unsubscribe header and open/click tracking enabled
    - verifyWebhookSignature() validates incoming webhook payloads using HMAC-SHA256
    - renderOfferEmail() generates professional 70% rule offer letter with all required metrics
    - All exports properly typed and testable
  </done>
</task>

<task type="auto">
  <name>Task 3: Webhook handler and offer generation endpoint</name>
  <files>
    src/app/api/offers/generate/route.ts
    src/app/api/email/sendgrid-webhook/route.ts
  </files>
  <action>
    **1. Create `src/app/api/offers/generate/route.ts`:**
    This endpoint generates offer email content (does NOT send yet — sending happens in Plan 03).

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { auth } from '@clerk/nextjs/server';
    import { prisma } from '@/lib/db';
    import { renderOfferEmail } from '@/lib/email/offerTemplate';
    import { calculateMAO } from '@/lib/qualification/engine';

    export async function POST(req: NextRequest) {
      const { userId } = await auth();

      if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const body = await req.json();
        const { dealId, recipientEmail, recipientName, repairCosts } = body;

        // Validate inputs
        if (!dealId || !recipientEmail) {
          return NextResponse.json(
            { error: 'dealId and recipientEmail required' },
            { status: 400 }
          );
        }

        // Fetch deal and verify ownership
        const deal = await prisma.deal.findUnique({
          where: { id: dealId },
          include: {
            property: true,
          },
        });

        if (!deal || deal.userId !== userId) {
          return NextResponse.json({ error: 'Deal not found' }, { status: 404 });
        }

        if (!deal.property) {
          return NextResponse.json(
            { error: 'Deal missing property data' },
            { status: 400 }
          );
        }

        // Calculate MAO
        const mao = calculateMAO(
          deal.property.estimatedValue || 0,
          repairCosts || 0
        );

        // Fetch user realtor info
        const user = await prisma.user.findUnique({
          where: { id: userId },
        });

        if (!user) {
          return NextResponse.json({ error: 'User not found' }, { status: 500 });
        }

        // Prepare offer email data
        const offerData = {
          propertyAddress: deal.property.address,
          propertyCity: deal.property.city,
          propertyState: deal.property.state,
          propertyZip: deal.property.zip,
          estimatedValue: deal.property.estimatedValue || 0,
          repairCosts: repairCosts || 0,
          mao,
          offerPrice: mao * 0.95, // 5% discount from MAO (user can customize later)
          equityPercent: deal.property.equityPercent || 0,
          realtor: {
            name: user.name || 'Deal Team',
            phone: process.env.REALTOR_PHONE || '+1-xxx-xxx-xxxx',
            email: user.email,
          },
        };

        // Render email template
        const emailContent = renderOfferEmail(offerData);

        return NextResponse.json({
          success: true,
          draft: {
            dealId,
            recipientEmail,
            recipientName,
            subject: 'Professional Offer for Your Property',
            html: emailContent.html,
            text: emailContent.text,
            offerData: {
              propertyAddress: offerData.propertyAddress,
              estimatedValue: offerData.estimatedValue,
              repairCosts: offerData.repairCosts,
              mao: offerData.mao,
              offerPrice: offerData.offerPrice,
            },
          },
        });
      } catch (error) {
        console.error('Offer generation error:', error);
        return NextResponse.json(
          { error: 'Failed to generate offer' },
          { status: 500 }
        );
      }
    }
    ```

    **2. Create `src/app/api/email/sendgrid-webhook/route.ts`:**
    This endpoint receives and processes SendGrid webhook events.

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { prisma } from '@/lib/db';
    import { verifyWebhookSignature } from '@/lib/email/sendgrid';
    import { SendgridEventType } from '@prisma/client';

    const SENDGRID_WEBHOOK_KEY = process.env.SENDGRID_WEBHOOK_KEY;

    if (!SENDGRID_WEBHOOK_KEY) {
      console.warn('SENDGRID_WEBHOOK_KEY not set — webhook verification will fail');
    }

    export async function POST(req: NextRequest) {
      try {
        const rawBody = await req.text();
        const signature = req.headers.get('x-twilio-email-event-signature');
        const timestamp = req.headers.get('x-twilio-email-timestamp');

        if (!signature || !timestamp || !SENDGRID_WEBHOOK_KEY) {
          console.warn('Missing webhook signature or key');
          return NextResponse.json(
            { error: 'Invalid webhook' },
            { status: 400 }
          );
        }

        // Verify signature
        const isValid = verifyWebhookSignature(
          rawBody,
          signature,
          timestamp,
          SENDGRID_WEBHOOK_KEY
        );

        if (!isValid) {
          console.warn('Invalid webhook signature');
          return NextResponse.json(
            { error: 'Invalid signature' },
            { status: 401 }
          );
        }

        const events = JSON.parse(rawBody);

        // Process each event
        for (const event of events) {
          const eventType = mapSendGridEventType(event.event);
          const messageId = event['message-id'];
          const email = event.email;

          // Store webhook event
          await prisma.sendgridWebhook.create({
            data: {
              eventType: eventType as SendgridEventType,
              email,
              timestamp: new Date(event.timestamp * 1000),
              messageId,
              bounceType: event.bounce_type,
              complaintType: event.complaint,
              url: event.url,
              rawPayload: event,
            },
          });

          // Update OfferedDeal status based on event type
          if (messageId) {
            const offeredDeal = await prisma.offeredDeal.findFirst({
              where: { sendgridMessageId: messageId },
            });

            if (offeredDeal) {
              const updateData: Record<string, any> = {};

              switch (event.event) {
                case 'open':
                  updateData.emailOpenedAt = new Date(event.timestamp * 1000);
                  updateData.status = 'OPENED';
                  break;
                case 'click':
                  updateData.linkClickedAt = new Date(event.timestamp * 1000);
                  updateData.status = 'CLICKED';
                  break;
                case 'bounce':
                  updateData.bouncedAt = new Date(event.timestamp * 1000);
                  updateData.bouncetype = event.bounce_type;
                  updateData.status = 'BOUNCED';
                  break;
                case 'spamreport':
                case 'complaint':
                  updateData.complainedAt = new Date(event.timestamp * 1000);
                  updateData.complaintType = event.complaint;
                  updateData.status = 'COMPLAINED';
                  break;
                case 'unsubscribe':
                  updateData.status = 'UNSUBSCRIBED';
                  break;
              }

              if (Object.keys(updateData).length > 0) {
                await prisma.offeredDeal.update({
                  where: { id: offeredDeal.id },
                  data: updateData,
                });
              }
            }
          }
        }

        return NextResponse.json({ success: true, processed: events.length });
      } catch (error) {
        console.error('Webhook processing error:', error);
        return NextResponse.json(
          { error: 'Webhook processing failed' },
          { status: 500 }
        );
      }
    }

    function mapSendGridEventType(sendgridEventType: string): string {
      const map: Record<string, SendgridEventType> = {
        delivered: 'DELIVERED',
        open: 'OPEN',
        click: 'CLICK',
        bounce: 'BOUNCE',
        spamreport: 'COMPLAINT',
        complaint: 'COMPLAINT',
        unsubscribe: 'UNSUBSCRIBE',
        group_unsubscribe: 'GROUP_UNSUBSCRIBE',
      };
      return map[sendgridEventType] || 'DELIVERED';
    }
    ```
  </action>
  <verify>
    1. `npm run build` passes TypeScript checks
    2. POST /api/offers/generate with valid dealId returns 200 with draft email object (html, text, subject, offerData)
    3. POST /api/offers/generate with invalid dealId returns 404
    4. POST /api/offers/generate with missing recipientEmail returns 400
    5. POST /api/email/sendgrid-webhook with invalid signature returns 401
    6. POST /api/email/sendgrid-webhook with valid payload creates SendgridWebhook record
    7. Check that webhook updates OfferedDeal status (OPENED, CLICKED, BOUNCED, etc.)
  </verify>
  <done>
    - POST /api/offers/generate returns professional offer email draft with MAO calculation
    - POST /api/email/sendgrid-webhook accepts and validates SendGrid events
    - Webhook handler updates OfferedDeal status and timestamps based on event type
    - All endpoints properly authenticated (offer endpoint) and validated (webhook signature)
    - Email content includes unsubscribe link and all required metrics
  </done>
</task>

</tasks>

<verification>
1. Schema migration applied cleanly with all new tables visible in Prisma Studio
2. SendGrid client configured with API key from environment
3. Offer template renders properly with all property metrics and unsubscribe link
4. Webhook handler verifies SendGrid signatures and processes events
5. Build passes TypeScript checks with no errors
6. All new exports are properly typed and documented
</verification>

<success_criteria>
- Database schema extended with OfferedDeal, SendgridWebhook, FollowUpSequence, FollowUpScheduled, FollowUpEvent tables
- SendGrid client library established and configured for sandbox/production modes
- Offer email template generates professional HTML + plain text with 70% rule calculations
- Webhook endpoint receives and logs SendGrid events (opens, clicks, bounces, complaints)
- POST /api/offers/generate creates draft offers with MAO calculation
- All endpoints properly authenticated and error-handled
- Migration committed to source control
</success_criteria>

<output>
After completion, create `.planning/phases/02-intelligent-offer-automation/02-01-SUMMARY.md`
</output>
