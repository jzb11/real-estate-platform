---
phase: 02-intelligent-offer-automation
plan: "03"
type: execute
wave: 2
depends_on:
  - "02-01"
  - "02-02"
files_modified:
  - src/app/api/offers/send/route.ts
  - src/app/api/offers/bulk-send/route.ts
  - src/lib/email/sendgrid.ts
  - src/lib/validation/listValidator.ts
  - .env.example
autonomous: true
requirements:
  - OF-04
  - OF-05
  - OF-06
  - OF-07

must_haves:
  truths:
    - "User can send a single offer to a recipient email with one API call"
    - "Offer is recorded in OfferedDeal table with status SENT and timestamp"
    - "User can bulk send 50+ offers in one batch operation (POST /api/offers/bulk-send)"
    - "Bulk send validates all recipient emails (removes invalid addresses before sending)"
    - "Each sent offer triggers the associated follow-up sequence automatically"
    - "System tracks delivery attempts and surfaces errors (hard bounces, invalid addresses)"
  artifacts:
    - path: "src/app/api/offers/send/route.ts"
      provides: "POST /api/offers/send for single offer send"
      exports: ["POST"]
    - path: "src/app/api/offers/bulk-send/route.ts"
      provides: "POST /api/offers/bulk-send for batch sending with validation"
      exports: ["POST"]
    - path: "src/lib/email/sendgrid.ts"
      provides: "Extended with sendOfferToRecipient() and bulkValidateEmails()"
      exports: ["sendOfferToRecipient", "bulkValidateEmails"]
    - path: "src/lib/validation/listValidator.ts"
      provides: "Email list validation using SendGrid List Validate API"
      exports: ["validateEmailList"]
  key_links:
    - from: "src/app/api/offers/send/route.ts"
      to: "src/lib/email/sendgrid.ts"
      via: "calls sendOfferToRecipient and creates OfferedDeal record"
      pattern: "sendOfferToRecipient"
    - from: "src/app/api/offers/bulk-send/route.ts"
      to: "src/lib/validation/listValidator.ts"
      via: "validateEmailList removes invalid addresses before send"
      pattern: "validateEmailList"
    - from: "src/app/api/offers/send/route.ts"
      to: "src/lib/queue/jobs.ts"
      via: "enqueueFollowUpSequence after offer sent"
      pattern: "scheduleFollowUpSequence"

user_setup:
  - service: sendgrid
    why: "List Validate API for email validation (prevents deliverability issues)"
    env_vars:
      - name: SENDGRID_LIST_VALIDATE_API_KEY
        source: "SendGrid Dashboard -> Settings -> API Keys (same as SENDGRID_API_KEY)"
      - name: NEXT_PUBLIC_BASE_URL
        source: "Your domain (used for unsubscribe links)"

---

<objective>
Implement single and bulk offer sending with email list validation. One-click offer send to single recipient, or batch 50+ offers with automatic validation.

Purpose: Users go from "I have a list of properties" to "50 offers sent automatically" without manual email cleanup. SendGrid List Validate removes invalid addresses upfront, preventing reputation damage from bounces.

Output: Working send API endpoints (single + bulk), email validation before send, OfferedDeal records created with proper tracking.
</objective>

<execution_context>
@/Users/jakezebe/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jakezebe/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-intelligent-offer-automation/02-CONTEXT.md
@.planning/phases/02-intelligent-offer-automation/02-RESEARCH.md
@.planning/phases/02-intelligent-offer-automation/02-01-SUMMARY.md
@.planning/phases/02-intelligent-offer-automation/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Email validation and single offer send</name>
  <files>
    src/lib/validation/listValidator.ts
    src/lib/email/sendgrid.ts
    src/app/api/offers/send/route.ts
  </files>
  <action>
    **1. Create `src/lib/validation/listValidator.ts`:**
    Email validation using SendGrid List Validate API.

    ```typescript
    import { prisma } from '@/lib/db';

    const SENDGRID_API_KEY = process.env.SENDGRID_API_KEY;

    export interface ValidateEmailResult {
      email: string;
      valid: boolean;
      reason?: string;
    }

    /**
     * Validate an email using SendGrid List Validate API
     * Costs ~$0.01 per validation
     */
    export async function validateEmailList(
      emails: string[]
    ): Promise<ValidateEmailResult[]> {
      if (!SENDGRID_API_KEY) {
        throw new Error('SENDGRID_API_KEY not set');
      }

      if (emails.length === 0) {
        return [];
      }

      try {
        const results: ValidateEmailResult[] = [];

        // Validate in batches (SendGrid allows up to 1000 per request)
        for (const email of emails) {
          try {
            const response = await fetch(
              'https://api.sendgrid.com/v3/validations/email',
              {
                method: 'POST',
                headers: {
                  Authorization: \`Bearer \${SENDGRID_API_KEY}\`,
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  email,
                  source: 'form',
                }),
              }
            );

            if (!response.ok) {
              results.push({
                email,
                valid: false,
                reason: \`API error: \${response.status}\`,
              });
              continue;
            }

            const data = await response.json();

            // SendGrid returns result: { valid: true/false, is_valid_format: bool, etc }
            results.push({
              email,
              valid: data.result?.verdict === 'Valid' || false,
              reason: data.result?.suggestion || undefined,
            });
          } catch (error) {
            console.error(\`Validation error for \${email}:\`, error);
            results.push({
              email,
              valid: false,
              reason: 'Validation failed',
            });
          }
        }

        return results;
      } catch (error) {
        console.error('Email list validation error:', error);
        throw error;
      }
    }

    /**
     * Validate a single email (common case)
     */
    export async function validateEmail(email: string): Promise<boolean> {
      const results = await validateEmailList([email]);
      return results[0]?.valid ?? false;
    }
    ```

    **2. Update `src/lib/email/sendgrid.ts` with new send function:**
    Add to the existing file:

    ```typescript
    /**
     * Send offer email to recipient and create OfferedDeal record
     * Called by both single send and bulk send endpoints
     */
    export async function sendOfferToRecipient(
      dealId: string,
      userId: string,
      recipientEmail: string,
      recipientName: string | undefined,
      htmlContent: string,
      plainText: string,
      subject: string = 'Professional Offer for Your Property'
    ) {
      try {
        // Send email
        const sendResult = await sendOfferEmail(
          recipientEmail,
          recipientName,
          htmlContent,
          plainText,
          subject
        );

        if (!sendResult.success) {
          throw new Error(\`SendGrid send failed: \${sendResult.statusCode}\`);
        }

        // Record in database (OfferedDeal)
        const offeredDeal = await prisma.offeredDeal.create({
          data: {
            dealId,
            userId,
            sentToEmail: recipientEmail,
            recipientName,
            status: 'SENT',
            sentAt: new Date(),
            sendgridMessageId: sendResult.messageId,
          },
        });

        return {
          success: true,
          offeredDealId: offeredDeal.id,
          messageId: sendResult.messageId,
        };
      } catch (error) {
        console.error('sendOfferToRecipient error:', error);
        throw error;
      }
    }
    ```

    **3. Create `src/app/api/offers/send/route.ts`:**
    Single offer send endpoint.

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { auth } from '@clerk/nextjs/server';
    import { prisma } from '@/lib/db';
    import { renderOfferEmail } from '@/lib/email/offerTemplate';
    import { sendOfferToRecipient } from '@/lib/email/sendgrid';
    import { validateEmail } from '@/lib/validation/listValidator';
    import { scheduleFollowUpSequence } from '@/lib/queue/jobs';
    import { z } from 'zod';

    const sendOfferSchema = z.object({
      dealId: z.string().uuid(),
      recipientEmail: z.string().email(),
      recipientName: z.string().optional(),
      repairCosts: z.number().default(0),
      sequenceId: z.string().uuid().optional(), // Optional follow-up sequence
    });

    export async function POST(req: NextRequest) {
      const { userId } = await auth();

      if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const body = await req.json();
        const parsed = sendOfferSchema.parse(body);

        const {
          dealId,
          recipientEmail,
          recipientName,
          repairCosts,
          sequenceId,
        } = parsed;

        // Fetch deal
        const deal = await prisma.deal.findUnique({
          where: { id: dealId },
          include: { property: true },
        });

        if (!deal || deal.userId !== userId) {
          return NextResponse.json(
            { error: 'Deal not found' },
            { status: 404 }
          );
        }

        if (!deal.property) {
          return NextResponse.json(
            { error: 'Deal missing property' },
            { status: 400 }
          );
        }

        // Validate email
        const isValid = await validateEmail(recipientEmail);
        if (!isValid) {
          return NextResponse.json(
            { error: 'Email address is invalid or undeliverable', email: recipientEmail },
            { status: 400 }
          );
        }

        // Generate offer email
        const { calculateMAO } = await import('@/lib/qualification/engine');
        const mao = calculateMAO(deal.property.estimatedValue || 0, repairCosts);

        const user = await prisma.user.findUnique({ where: { id: userId } });
        if (!user) {
          return NextResponse.json({ error: 'User not found' }, { status: 500 });
        }

        const offerData = {
          propertyAddress: deal.property.address,
          propertyCity: deal.property.city,
          propertyState: deal.property.state,
          propertyZip: deal.property.zip,
          estimatedValue: deal.property.estimatedValue || 0,
          repairCosts,
          mao,
          offerPrice: mao * 0.95,
          equityPercent: deal.property.equityPercent || 0,
          realtor: {
            name: user.name || 'Deal Team',
            phone: process.env.REALTOR_PHONE || '+1-xxx-xxx-xxxx',
            email: user.email,
          },
        };

        const emailContent = renderOfferEmail(offerData);

        // Send offer
        const sendResult = await sendOfferToRecipient(
          dealId,
          userId,
          recipientEmail,
          recipientName,
          emailContent.html,
          emailContent.text
        );

        // Schedule follow-up sequence if provided
        let sequenceScheduled = null;
        if (sequenceId) {
          const scheduled = await prisma.followUpScheduled.create({
            data: {
              dealId,
              userId,
              sequenceId,
              currentStep: 0,
              nextStepAt: new Date(Date.now() + 86400000), // Start in 1 day
            },
          });

          // Enqueue sequence
          await scheduleFollowUpSequence(
            scheduled.id,
            dealId,
            userId,
            sequenceId,
            recipientEmail,
            recipientName
          );

          sequenceScheduled = {
            id: scheduled.id,
            sequenceId,
            nextStepAt: scheduled.nextStepAt,
          };
        }

        // Update deal with offer info
        await prisma.deal.update({
          where: { id: dealId },
          data: {
            customFields: {
              ...((deal.customFields as any) || {}),
              lastOfferSentTo: recipientEmail,
              lastOfferSentAt: new Date().toISOString(),
            },
          },
        });

        return NextResponse.json({
          success: true,
          offeredDealId: sendResult.offeredDealId,
          messageId: sendResult.messageId,
          sequenceScheduled,
        });
      } catch (error: any) {
        if (error instanceof z.ZodError) {
          return NextResponse.json(
            { error: 'Invalid input', details: error.errors },
            { status: 400 }
          );
        }
        console.error('Send offer error:', error);
        return NextResponse.json(
          { error: 'Failed to send offer' },
          { status: 500 }
        );
      }
    }
    ```
  </action>
  <verify>
    1. validateEmailList() returns array of { email, valid, reason }
    2. validateEmail() returns boolean for single email
    3. sendOfferToRecipient() creates OfferedDeal record with SENT status
    4. POST /api/offers/send with valid inputs returns 200 with offeredDealId and messageId
    5. POST /api/offers/send with invalid email returns 400 with validation error
    6. POST /api/offers/send with invalid dealId returns 404
    7. POST /api/offers/send with sequenceId enqueues follow-up sequence
    8. Verify deal.customFields updated with lastOfferSentTo and lastOfferSentAt
  </verify>
  <done>
    - validateEmail() validates addresses via SendGrid List Validate API
    - sendOfferToRecipient() sends email and creates OfferedDeal record atomically
    - POST /api/offers/send sends single offer with email validation
    - Follow-up sequence automatically scheduled if sequenceId provided
    - Deal customFields updated with offer tracking info
    - All endpoints properly error-handled (validation errors, missing deal, etc.)
  </done>
</task>

<task type="auto">
  <name>Task 2: Bulk offer send with validation and error recovery</name>
  <files>
    src/app/api/offers/bulk-send/route.ts
  </files>
  <action>
    Create `src/app/api/offers/bulk-send/route.ts`. Bulk send is fire-and-forget; individual failures logged.

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { auth } from '@clerk/nextjs/server';
    import { prisma } from '@/lib/db';
    import { renderOfferEmail } from '@/lib/email/offerTemplate';
    import { sendOfferToRecipient } from '@/lib/email/sendgrid';
    import { validateEmailList } from '@/lib/validation/listValidator';
    import { scheduleFollowUpSequence } from '@/lib/queue/jobs';
    import { z } from 'zod';

    const bulkSendSchema = z.object({
      dealIds: z.array(z.string().uuid()).min(1).max(100),
      recipientEmail: z.string().email(),
      recipientName: z.string().optional(),
      repairCosts: z.number().default(0),
      sequenceId: z.string().uuid().optional(),
      validateEmail: z.boolean().default(true),
    });

    export async function POST(req: NextRequest) {
      const { userId } = await auth();

      if (!userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }

      try {
        const body = await req.json();
        const parsed = bulkSendSchema.parse(body);

        const {
          dealIds,
          recipientEmail,
          recipientName,
          repairCosts,
          sequenceId,
          validateEmail: shouldValidate,
        } = parsed;

        // Validate email if requested
        if (shouldValidate) {
          const validation = await validateEmailList([recipientEmail]);
          if (!validation[0]?.valid) {
            return NextResponse.json(
              {
                error: 'Email address is invalid or undeliverable',
                email: recipientEmail,
              },
              { status: 400 }
            );
          }
        }

        // Fetch all deals for user
        const deals = await prisma.deal.findMany({
          where: {
            id: { in: dealIds },
            userId,
          },
          include: { property: true },
        });

        if (deals.length === 0) {
          return NextResponse.json(
            { error: 'No valid deals found' },
            { status: 404 }
          );
        }

        // Filter deals that have properties
        const validDeals = deals.filter((d) => d.property);

        const user = await prisma.user.findUnique({ where: { id: userId } });
        if (!user) {
          return NextResponse.json({ error: 'User not found' }, { status: 500 });
        }

        const results = {
          total: validDeals.length,
          sent: 0,
          failed: 0,
          errors: [] as Array<{ dealId: string; error: string }>,
        };

        // Send to each deal
        for (const deal of validDeals) {
          try {
            const { calculateMAO } = await import(
              '@/lib/qualification/engine'
            );
            const mao = calculateMAO(
              deal.property!.estimatedValue || 0,
              repairCosts
            );

            const offerData = {
              propertyAddress: deal.property!.address,
              propertyCity: deal.property!.city,
              propertyState: deal.property!.state,
              propertyZip: deal.property!.zip,
              estimatedValue: deal.property!.estimatedValue || 0,
              repairCosts,
              mao,
              offerPrice: mao * 0.95,
              equityPercent: deal.property!.equityPercent || 0,
              realtor: {
                name: user.name || 'Deal Team',
                phone: process.env.REALTOR_PHONE || '+1-xxx-xxx-xxxx',
                email: user.email,
              },
            };

            const emailContent = renderOfferEmail(offerData);

            // Send offer
            await sendOfferToRecipient(
              deal.id,
              userId,
              recipientEmail,
              recipientName,
              emailContent.html,
              emailContent.text
            );

            // Schedule sequence if provided
            if (sequenceId) {
              const scheduled = await prisma.followUpScheduled.create({
                data: {
                  dealId: deal.id,
                  userId,
                  sequenceId,
                  currentStep: 0,
                  nextStepAt: new Date(Date.now() + 86400000),
                },
              });

              await scheduleFollowUpSequence(
                scheduled.id,
                deal.id,
                userId,
                sequenceId,
                recipientEmail,
                recipientName
              );
            }

            results.sent++;
          } catch (error: any) {
            results.failed++;
            results.errors.push({
              dealId: deal.id,
              error: error.message || 'Unknown error',
            });
            console.error(\`Bulk send error for deal \${deal.id}:\`, error);
          }
        }

        return NextResponse.json({
          success: results.failed === 0,
          results,
        });
      } catch (error: any) {
        if (error instanceof z.ZodError) {
          return NextResponse.json(
            { error: 'Invalid input', details: error.errors },
            { status: 400 }
          );
        }
        console.error('Bulk send error:', error);
        return NextResponse.json(
          { error: 'Bulk send operation failed' },
          { status: 500 }
        );
      }
    }
    ```
  </action>
  <verify>
    1. POST /api/offers/bulk-send with 10 dealIds and valid email returns 200
    2. Check response includes results: { total, sent, failed, errors[] }
    3. OfferedDeal records created for each successful send
    4. Failed deals logged in errors array but don't stop remaining sends
    5. Email validation prevents send if recipientEmail is invalid (validateEmail: true)
    6. validateEmail: false bypasses validation (for already-validated lists)
    7. Follow-up sequences enqueued for each deal if sequenceId provided
    8. Verify max 100 dealIds enforced
  </verify>
  <done>
    - POST /api/offers/bulk-send sends to multiple deals in single request
    - Email validation optional (validateEmail flag)
    - Partial failures recorded (one deal failing doesn't stop others)
    - Response includes granular results: total/sent/failed and per-deal errors
    - Follow-up sequences scheduled for all successful sends if sequenceId provided
    - All errors logged without breaking bulk operation
    - Max 100 deals per bulk send (SafeGuard against accidental spam)
  </done>
</task>

</tasks>

<verification>
1. Email validation via SendGrid List Validate API working
2. Single offer send endpoint functional and creating OfferedDeal records
3. Bulk send handles 50+ deals in one batch
4. Failed sends logged in results array without stopping batch
5. Follow-up sequences automatically scheduled when provided
6. Email validation prevents invalid addresses from being sent
7. Build passes TypeScript checks
</verification>

<success_criteria>
- POST /api/offers/send sends single offer with email validation
- POST /api/offers/bulk-send sends multiple offers in one batch (max 100)
- OfferedDeal records created with sentAt timestamp and SENT status
- SendGrid message ID tracked for open/click events
- Failed sends logged granularly without stopping batch operation
- Email validation prevents deliverability issues (>5% bounce rate)
- Follow-up sequences automatically scheduled if sequenceId provided
- Deal customFields updated with offer tracking info
</success_criteria>

<output>
After completion, create `.planning/phases/02-intelligent-offer-automation/02-03-SUMMARY.md`
</output>
